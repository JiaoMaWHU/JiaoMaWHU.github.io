<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jinshin&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://jiaomawhu.github.io/"/>
  <updated>2021-01-18T02:44:57.311Z</updated>
  <id>https://jiaomawhu.github.io/</id>
  
  <author>
    <name>Jinshin</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Containers Reminder</title>
    <link href="https://jiaomawhu.github.io/2020/05/31/cscore/docker/"/>
    <id>https://jiaomawhu.github.io/2020/05/31/cscore/docker/</id>
    <published>2020-06-01T03:35:36.000Z</published>
    <updated>2021-01-18T02:44:57.311Z</updated>
    
    <content type="html"><![CDATA[<p>This post summarizes the key concepts and commonly used commands of Dockers and Kubernetes.<br><a id="more"></a></p><h1 id="Containers"><a href="#Containers" class="headerlink" title="Containers"></a>Containers</h1><p>Containers are a way to provide isolation. It is based on the following concepts.</p><h2 id="1-chroot"><a href="#1-chroot" class="headerlink" title="1. chroot"></a>1. chroot</h2><ul><li><code>chroot</code> is a way to isolate a directory. Using this command, you can set a target directory as the root directory.</li><li>After getting into that dir using <code>chroot</code>, you cannot access anything out of the dir.</li><li>Consider a use case. A <code>makebox.sh</code> contains the following content.<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#! /bin/bash</span></span><br><span class="line">mkdir box</span><br><span class="line">mkdir box/bin</span><br><span class="line">cp -v /bin/bash /home/class/box/bin</span><br><span class="line">cp -v /bin/ls /home/class/box/bin</span><br><span class="line">mkdir box/lib</span><br><span class="line">mkdir box/lib64</span><br><span class="line">cp /lib/x86_64-linux-gnu/libselinux.so.1 box/lib</span><br><span class="line">cp /lib/x86_64-linux-gnu/libc.so.6 box/lib</span><br><span class="line">cp /lib/x86_64-linux-gnu/libpcre.so.3 box/lib</span><br><span class="line">cp /lib/x86_64-linux-gnu/libdl.so.2 box/lib</span><br><span class="line">cp /lib64/ld-linux-x86-64.so.2 box/lib64</span><br><span class="line">cp /lib/x86_64-linux-gnu/libpthread.so.0 box/lib</span><br><span class="line">cp /lib/x86_64-linux-gnu/libtinfo.so.6 box/lib</span><br><span class="line">cp /lib/x86_64-linux-gnu/libtinfo.so.6 box/lib</span><br></pre></td></tr></table></figure></li></ul><p>Then, use this command <code>sudo chroot $HOME/box /bin/bash</code>, we will get into the box dir, and it is able to use the tools that we copied like <code>ls</code>, but that’s all.</p><h2 id="2-cgroups"><a href="#2-cgroups" class="headerlink" title="2. cgroups"></a>2. cgroups</h2><p><code>cgroups</code> is short for Control Groups. Developed in 2006 by 2 google engineers. In 2008 it was added to the Linux kernel 2.6.24. Used by many container projects, Docker, LXC.</p><p><code>cgroup</code> can be used to</p><ul><li>limit resources: Groups can be set to not exceed a configured memory limit.</li><li>prioritize: Some groups may get a larger share of CPU utilization or disk I/O throughput.</li><li>measure the resource usage of a group.</li><li>control groups: freezing groups of processes, their checkpointing and restarting.</li></ul><h2 id="3-namespace"><a href="#3-namespace" class="headerlink" title="3. namespace"></a>3. namespace</h2><p>Namespace enables a process to have a different view of the system than other processes, which provides a way for isolation.</p><p>The 7 namespaces are Cgourp, IPC, Network, Mount, PID, User, UTS (host name and NIS domain name). One can use these namespace to isolate corresponding resources. </p><p>The use of namespace is related with a few linux commands, which will not be included here.</p><h2 id="Roles"><a href="#Roles" class="headerlink" title="Roles"></a>Roles</h2><p>The roles of the three concepts in dockers are,</p><ul><li><code>chroot</code> restricts access to the filesystem.</li><li><code>cgrups</code> restricts access to the system resources.</li><li>namespaces provide isolation.</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;This post summarizes the key concepts and commonly used commands of Dockers and Kubernetes.&lt;br&gt;
    
    </summary>
    
    
      <category term="Algorithms" scheme="https://jiaomawhu.github.io/tags/Algorithms/"/>
    
  </entry>
  
  <entry>
    <title>Computer Network Key notes.</title>
    <link href="https://jiaomawhu.github.io/2020/05/31/cscore/network/"/>
    <id>https://jiaomawhu.github.io/2020/05/31/cscore/network/</id>
    <published>2020-06-01T00:05:53.000Z</published>
    <updated>2021-01-18T02:45:36.908Z</updated>
    
    <content type="html"><![CDATA[<p>This post is a note of computer network key points and useful tools and is organized according to the TCP/IP model.<br><a id="more"></a></p><h1 id="Link-Layer"><a href="#Link-Layer" class="headerlink" title="Link Layer"></a>Link Layer</h1><h2 id="ARP"><a href="#ARP" class="headerlink" title="ARP"></a>ARP</h2><h2 id="MAC"><a href="#MAC" class="headerlink" title="MAC"></a>MAC</h2><h2 id="PPP"><a href="#PPP" class="headerlink" title="PPP"></a>PPP</h2><h2 id="CSMA-CD"><a href="#CSMA-CD" class="headerlink" title="CSMA/CD"></a>CSMA/CD</h2><h2 id="Misc"><a href="#Misc" class="headerlink" title="Misc"></a>Misc</h2><h3 id="CAN-Bus"><a href="#CAN-Bus" class="headerlink" title="CAN Bus"></a>CAN Bus</h3><h1 id="Internet-Layer"><a href="#Internet-Layer" class="headerlink" title="Internet Layer"></a>Internet Layer</h1><h2 id="IP-Internet-Protocol"><a href="#IP-Internet-Protocol" class="headerlink" title="IP (Internet Protocol)"></a>IP (Internet Protocol)</h2><p>IP address is a 32 bit number represented by a grouping of 4 octets.</p><ul><li>192.168.0.1</li><li>In hex: c0 a8 00 01</li></ul><h2 id="CIDR"><a href="#CIDR" class="headerlink" title="CIDR"></a>CIDR</h2><ul><li>Classless Inter-Domain Routing.</li><li>Notation for talking about ranges of IP address.</li><li>Rare to see 192.168.0.0 - 192.168.0.255.</li><li>Instead you would see 192.168.0.0/24.</li><li>Equevalant to matching a netmask of 255.255.255.0.</li><li>value after the / is called the prefix length</li><li>0.0.0.0/8 = Class A</li><li>0.0.0.0/16 = Class B</li><li>0.0.0.0/24 = Class C</li></ul><h2 id="ICMP"><a href="#ICMP" class="headerlink" title="ICMP"></a>ICMP</h2><h2 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h2><p>A Request for Comments (RFC) is a formal document drafted by the Internet Engineering Task Force (IETF) that describes the specifications for a particular technology. When an RFC is ratified, it becomes a formal standards document.</p><p>RFCs were first used during the creation of the ARPANET (predecessor of Internet) protocols that came to establish what became today’s Internet. They continue to be issued on an ongoing basis as the technology underlying the Internet evolves.</p><h1 id="Transport-Layer"><a href="#Transport-Layer" class="headerlink" title="Transport Layer"></a>Transport Layer</h1><h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><h2 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h2><h1 id="Application-Layer"><a href="#Application-Layer" class="headerlink" title="Application Layer"></a>Application Layer</h1><h3 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h3><p>DNS resolves the network address to the IP address.</p><p>For linux, the local DNS server is in <code>/etc/resolv.conf</code></p><p>DNS is a distributed and decentralized hierarchical database (organized by ICANN)</p><ul><li>root server -&gt; 13 labeled A-M<ul><li>some of the root servers have mirrors all the over world</li></ul></li><li>Top Level Domain server<ul><li>com, org, edu</li></ul></li><li>Authoritative DNS server<ul><li>amazon.com, utexas.edu</li></ul></li></ul><p><code>nslookup xxx.com</code> will show up the IP address of the network address.</p><p><code>whois</code> provides more info about the IP from the whois database</p><p><code>dig</code> similar to nslookup</p><p><code>nmap</code> is a network exploration tool and security / port scanner</p><ul><li><code>-A</code> aggressive, detect vulnerable, </li><li><code>-O</code> OS detection</li></ul><p><code>Zmap</code> is a network tool for scanning the entire Internet (or large samples).</p><h2 id="HTTP-S"><a href="#HTTP-S" class="headerlink" title="HTTP(S)"></a>HTTP(S)</h2><h2 id="TLS-SSL"><a href="#TLS-SSL" class="headerlink" title="TLS/SSL"></a>TLS/SSL</h2><h2 id="SSH"><a href="#SSH" class="headerlink" title="SSH"></a>SSH</h2><h2 id="Telnet"><a href="#Telnet" class="headerlink" title="Telnet"></a>Telnet</h2><h2 id="SMTP"><a href="#SMTP" class="headerlink" title="SMTP"></a>SMTP</h2><h2 id="FTP"><a href="#FTP" class="headerlink" title="FTP"></a>FTP</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;This post is a note of computer network key points and useful tools and is organized according to the TCP/IP model.&lt;br&gt;
    
    </summary>
    
    
      <category term="Algorithms" scheme="https://jiaomawhu.github.io/tags/Algorithms/"/>
    
  </entry>
  
  <entry>
    <title>Git Summary</title>
    <link href="https://jiaomawhu.github.io/2020/05/15/tools/git/"/>
    <id>https://jiaomawhu.github.io/2020/05/15/tools/git/</id>
    <published>2020-05-15T21:28:14.000Z</published>
    <updated>2021-01-18T02:46:45.375Z</updated>
    
    <content type="html"><![CDATA[<p>A summary of git data model and commonly used commands.<br><a id="more"></a></p><h2 id="Data-model"><a href="#Data-model" class="headerlink" title="Data model"></a>Data model</h2><p>Git is created by Linus to manage the Linux repository, so it’s designed for efficient repository changes tracking and version restoring and branch merging, etc.</p><p>Now, thinking as the creator, what should we consider to properly manage a repository? I’ll say that includes file,  directory, and modification.</p><p>In git, the data model of these structures are as follows.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// a file is a bunch of bytes</span><br><span class="line">type blob = array&lt;byte&gt;</span><br><span class="line"></span><br><span class="line">// a directory contains named files and directories</span><br><span class="line">type tree = map&lt;string, tree | file&gt;</span><br><span class="line"></span><br><span class="line">// a commit has parents, metadata, and the top-level tree</span><br><span class="line">type commit = struct &#123;</span><br><span class="line">    parent: array&lt;commit&gt;</span><br><span class="line">    author: string</span><br><span class="line">    message: string</span><br><span class="line">    snapshot: tree</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>A snapshot is the top-level tree that is being tracked. In the below example, a snapshot could be a tracked version of the root tree. And a commit contains not only the snapshot at this version but the parent commit, author, and message. </p><p>Now, it’s easy to image how these models can represent the whole structure, dependencies, modifications of a repository.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;root&gt; (tree)</span><br><span class="line">|</span><br><span class="line">+- foo (tree)</span><br><span class="line">|  |</span><br><span class="line">|  + bar.txt (blob, contents = &quot;hello world&quot;)</span><br><span class="line">|</span><br><span class="line">+- baz.txt (blob, contents = &quot;git is wonderful&quot;)</span><br></pre></td></tr></table></figure><p>In fact, a git history is a <strong>directed acyclic graph (DAG)</strong> of commits. Visualizing a commit history might look something like this:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">o &lt;-- o &lt;-- o &lt;-- o</span><br><span class="line">            ^  </span><br><span class="line">             \</span><br><span class="line">              --- o &lt;-- o</span><br></pre></td></tr></table></figure></p><p>where each “o”, i.e. commit, is pointing to its parent commit (the older commit). After the third commit, the history branches into two separate branches. This might correspond to, for example, two separate features being developed in parallel, independently from each other.</p><h2 id="Objects-and-content-addressing"><a href="#Objects-and-content-addressing" class="headerlink" title="Objects and content-addressing"></a>Objects and content-addressing</h2><p>In Git data store, Blobs, trees, and commits are unified in this way: they are all objects. All objects are <strong>content-addressed</strong> by their SHA-1 hash (i.e. a hashed string with 40 characters).  When they reference other objects, they don’t actually contain them in their on-disk representation, but have a reference to them by their hash.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">type object = blob | tree | commit</span><br><span class="line">objects = map&lt;string, object&gt;</span><br></pre></td></tr></table></figure></p><p>You can easily image this using the idea of pointer references, the only difference is that git uses the hashed values for addressing the content.</p><p>Since git uses content addressable storage, it means that commits in Git are immutable. This doesn’t mean that mistakes can’t be corrected, however; it’s just that “edits” to the commit history are actually creating entirely new commits.</p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><p>Now, all snapshots can be identified by their SHA-1 hash. That’s inconvenient, because humans aren’t good at remembering strings of 40 hexadecimal characters.</p><p> Solution to this problem is human-readable names for SHA-1 hashes, called “references”. References are pointers to commits. Unlike objects, which are immutable, references are mutable (can be updated to point to a new commit). For example, the master reference usually points to the latest commit in the main branch of development.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">references = map&lt;string, string&gt;</span><br></pre></td></tr></table></figure><p>With this, Git can use human-readable names like “master” to refer to a particular snapshot in the history, instead of a long hexadecimal string.</p><p>One detail is that we often want a notion of “where we currently are” in the history, so that when we take a new snapshot, we know what it is relative to (how we set the parents field of the commit). In Git, that “where we currently are” is a special reference called “HEAD”.</p><h2 id="Repositories"><a href="#Repositories" class="headerlink" title="Repositories"></a>Repositories</h2><p>Finally, we can define what (roughly) is a Git repository: it is the data <strong>objects</strong> and <strong>references</strong>.</p><p>On disk, all Git stores are objects and references: that’s all there is to Git’s data model. All git commands map to some manipulation of the commit DAG by adding objects and adding/updating references.</p><p>Whenever you’re typing in any command, think about what manipulation the command is making to the underlying graph data structure.</p><h2 id="Staging-area"><a href="#Staging-area" class="headerlink" title="Staging area"></a>Staging area</h2><p>One more thing to mention is that, imaging a scenario where you have print logs in your repository; you want to commit the code while discarding all the logs.</p><p>Git accommodates such scenarios by allowing you to specify which modifications should be included in the next snapshot through a mechanism called the “staging area”.</p><h2 id="Commands"><a href="#Commands" class="headerlink" title="Commands"></a>Commands</h2><p>Now let’s see some commonly used git commands. Before we get started, we should be able to relate the following figure with the concepts we discussed above, so that it’ll be easy to understand and memorize the git commands.</p><p><img src="/images/git_structure.png" alt="Git Components."></p><h3 id="Basics"><a href="#Basics" class="headerlink" title="Basics"></a>Basics</h3><ul><li><code>git init</code>: creates a new git repo, with data stored in the .git directory</li><li><code>git status</code>: tells you what’s going on</li><li><code>git add &lt;filename&gt;</code>: adds files to staging area</li><li><code>git commit</code>: creates a new commit</li><li><code>git log --all --graph --decorate</code>: visualizes history as a DAG</li><li><code>git diff &lt;filename&gt;</code>: show differences since the last commit</li><li><code>git diff &lt;revision&gt; &lt;revision&gt; &lt;filename&gt;</code>: shows differences in a file between snapshots</li></ul><h3 id="Undo-Checkout-and-Reset"><a href="#Undo-Checkout-and-Reset" class="headerlink" title="Undo, Checkout and Reset"></a>Undo, Checkout and Reset</h3><p>The status of git files is as follows.<br><img src="https://git-scm.com/book/en/v2/images/lifecycle.png" alt="status of git files"></p><ul><li><code>git commit --amend</code>: lets you combine staged changes with the previous commit instead of creating an entirely new commit. It can also be used to simply edit the previous commit message without changing its snapshot (creating a new one).</li><li><code>git checkout</code>: Updates files in the working tree to match the version in the index or the specified tree. If no <code>pathspec</code> was given, it will also update <strong>HEAD</strong> to set the specified branch as the current branch.<ul><li><code>git checkout &lt;revision&gt;</code>: no <code>pathspec</code>, updates <strong>HEAD</strong> and current branch</li><li><code>git checkout &lt;--&gt; &lt;file&gt;</code>: restore a file <strong>only</strong> to the workspace from the staging area</li><li><code>git checkout &lt;commit&gt; &lt;file&gt;</code>: restore a file to <strong>workspace</strong> and <strong>the staging area</strong> using the <code>commit</code> version in repository.</li></ul></li><li><code>git reset</code>: Reset the <strong>HEAD</strong> of current branch to the specified state.<ul><li>For <strong>HEAD</strong>: <code>git reset &lt;--soft | --mixed [-N] | --hard | --merge | --keep&gt;</code>: see the following table.</li><li>For files: <code>git reset &lt;commit&gt; &lt;file&gt;</code>: unstage a file, i.e, copy entries from <code>&lt;commit&gt;</code> to the staging area.</li></ul></li><li><p>To differentiate <code>reset</code> and <code>checkout</code>, check the following table.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">                         head    stage   work dir  wd safe</span><br><span class="line">Commit Level</span><br><span class="line">reset --soft [commit]    REF     NO      NO        YES</span><br><span class="line">reset [commit]           REF     YES     NO        YES</span><br><span class="line">reset --hard [commit]    REF     YES     YES       NO</span><br><span class="line">checkout [commit]        YES     YES     NO        YES</span><br><span class="line"></span><br><span class="line">File Level</span><br><span class="line">reset (commit) [file]    NO      YES     NO        YES</span><br><span class="line">checkout (commit) [file] NO      YES     YES       NO</span><br></pre></td></tr></table></figure></li><li><p>Note that reset will change the Reference values (REF) in <strong>HEAD</strong>, while checkout only load a new value to <strong>HEAD</strong>, which can be visualized as follows.<br><img src="/images/reset-co.png" alt="One more difference"></p></li><li>If we need to restore a file or the entire repository to a specific version, we can use <code>checkout [commit] .</code> so that we load the target content to the stage and the work dir, and <strong>HEAD</strong> won’t be changed. Instead, <code>reset [commit] .</code> won’t do anything to the work dir. </li><li>But if we want to discard all commits after <code>[commit]</code>, we should use <code>reset --hard [commit]</code> since <code>checkout</code> will load <strong>HEAD</strong> as that commit.</li><li><code>git stash</code> and <code>git stash pop</code>: temporarily remove modifications to working directory</li><li><code>git revert &lt;commit&gt;</code>: undo the changes of the <code>[commit]</code> in <strong>HEAD</strong> and create a new commit.</li><li><code>git restore &lt;file&gt;</code>: by default, load content from the staging area in <strong>HEAD</strong>.</li></ul><h3 id="Remote"><a href="#Remote" class="headerlink" title="Remote"></a>Remote</h3><ul><li><code>git remote</code>: list remotes</li><li><code>git remote add &lt;name&gt; &lt;url&gt;</code>: add a remote</li><li><code>git push &lt;remote&gt; &lt;local branch&gt;:&lt;remote branch&gt;</code>: send objects to remote, and update remote reference</li><li><code>git branch --set-upstream-to=&lt;remote&gt;/&lt;remote branch&gt;</code>: set up correspondence between local and remote branch</li><li><code>git branch -u o/master foo</code>: will set the foo branch to track o/master.</li><li><code>git fetch &lt;remote&gt; &lt;remote branch&gt;:&lt;local branch&gt;</code>: retrieve objects/references from a remote branch, it doesn’t require <strong>HEAD</strong> to be on target <code>&lt;commit&gt;</code>, and it doesn’t update your local non-remote branches. If no branch specified, fetch all the branches. </li><li><code>git pull &lt;remote&gt; &lt;remote branch&gt;:&lt;local branch&gt;</code>: During a pull operation, commits are downloaded onto o/master and then merged into the current branch. It basically a <code>fetch</code> and a <code>merge</code>.</li><li><code>git clone</code>: download repository from remote</li></ul><h3 id="Branching-and-merging"><a href="#Branching-and-merging" class="headerlink" title="Branching and merging"></a>Branching and merging</h3><ul><li><code>git branch</code>: shows branches</li><li><code>git branch &lt;name&gt;</code>: creates a branch</li><li><code>git checkout -b &lt;name&gt;</code>: creates a branch and switches to it</li><li><code>git merge &lt;revision&gt;</code>: merges <code>&lt;revision&gt;</code> into current branch</li><li><code>git merge --abort</code>: abort a merge.</li><li><code>git mergetool</code>: use a fancy tool to help resolve merge conflicts</li><li><code>git rebase &lt;to-branch&gt; &lt;from-branch&gt;</code>: rebase set of patches of <code>&lt;from-branch&gt;</code> onto a new base, i.e. <code>&lt;to-branch&gt;</code>. If your master branch is <code>A-B-C</code>, and you do rebase to master on another branch: <code>A-B-D</code>, the <strong>HEAD</strong> will be set to master branch, and now master branch is <code>A-B-C-D</code>. It also can be used to combine a few commits to one commit before merging, so that we won’t have to much separate information. Another adv of rebase is that it can simplify the process of merging. This <a href="http://jartto.wang/2018/12/11/git-rebase/" target="_blank" rel="noopener">Chinese post</a> is very helpful to understand <code>rebase</code>.</li></ul><h3 id="Advanced-Git"><a href="#Advanced-Git" class="headerlink" title="Advanced Git"></a>Advanced Git</h3><ul><li><code>git config</code>: Git is highly customizable</li><li><code>git clone --shallow</code>: clone without entire version history</li><li><code>git add -p</code>: interactive staging</li><li><code>git rebase -i</code>: interactive rebasing</li><li><code>git blame</code>: show who last edited which line</li><li><code>git bisect</code>: binary search history (e.g. for regressions)</li><li><code>git tag [commit]</code>: Create a tag on [commit], it is permanent, unlike branches. If you leave the commit off, git will just use whatever HEAD is at</li><li><code>git describe &lt;ref&gt;</code>: tell you where you are relative to the closest “anchor” (aka tag)</li><li><code>.gitignore</code>: specify intentionally untracked files to ignore</li></ul><h3 id="Miscellaneous"><a href="#Miscellaneous" class="headerlink" title="Miscellaneous"></a>Miscellaneous</h3><ul><li>Use relative ref: the first parent of C1: <code>C1^</code>, the second parent: <code>C1^2</code>，the parent of C1’s parent: <code>C1^^</code>, find the xth ancestor of C1: <code>C1~x</code>.</li><li><code>git branch -f [branch] [commit], git reset [commit] (current branch)</code>: move the point of a branch to a specific commit</li><li><code>git checkout [commit]</code>: use this command to set <strong>HEAD</strong> to commits (not branch)</li><li><code>git cherry-pick [commits]</code>: replicate commits under current <strong>HEAD</strong>.</li></ul><h3 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h3><p>The following figure visualizes commonly used git commands.<br><img src="https://user-gold-cdn.xitu.io/2018/4/25/162fcc0e7e711dc7?imageslim" alt="Detailed relations."></p><h2 id="Resources"><a href="#Resources" class="headerlink" title="Resources"></a>Resources</h2><ol><li>The text of this post is largely based on <a href="https://missing.csail.mit.edu/2020/version-control/" target="_blank" rel="noopener">MIT The missing semester</a>, <a href="http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html" target="_blank" rel="noopener">RuanYifeng Blog</a>, <a href="https://segmentfault.com/a/1190000006185954" target="_blank" rel="noopener">chanjarster post</a>.</li><li>Two exercises are recommended: <a href="https://github.com/git-game/git-game" target="_blank" rel="noopener">git-game</a>, <a href="https://learngitbranching.js.org/" target="_blank" rel="noopener">branching game</a>.</li><li><a href="https://marklodato.github.io/visual-git-guide/index-zh-cn.html#rebase" target="_blank" rel="noopener">Visualize Git</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;A summary of git data model and commonly used commands.&lt;br&gt;
    
    </summary>
    
    
      <category term="Tools" scheme="https://jiaomawhu.github.io/tags/Tools/"/>
    
  </entry>
  
  <entry>
    <title>Multicore Algorithm Summary</title>
    <link href="https://jiaomawhu.github.io/2020/05/03/cscore/multicore/"/>
    <id>https://jiaomawhu.github.io/2020/05/03/cscore/multicore/</id>
    <published>2020-05-03T17:20:20.000Z</published>
    <updated>2021-01-18T02:45:32.365Z</updated>
    
    <content type="html"><![CDATA[<p>This post is a summary of common parallel algorithms and the implementation of common parallel data structures. The resource comes from the UT EE361C course I took this semester.<br><a id="more"></a></p><h3 id="Tree-Algorithm"><a href="#Tree-Algorithm" class="headerlink" title="Tree Algorithm"></a>Tree Algorithm</h3><p>Euler Tour Technique is used to get O(log n) time parallel algorithms for solving problems related to trees with n nodes.</p><p>First, Euler tour can be used to compute the height of a tree in O(logn) time, no matter the tree is balanced or not.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;This post is a summary of common parallel algorithms and the implementation of common parallel data structures. The resource comes from the UT EE361C course I took this semester.&lt;br&gt;
    
    </summary>
    
    
      <category term="Algorithms" scheme="https://jiaomawhu.github.io/tags/Algorithms/"/>
    
  </entry>
  
  <entry>
    <title>梯度下降(GD, SGD)总结</title>
    <link href="https://jiaomawhu.github.io/2020/04/11/ml/sgd/"/>
    <id>https://jiaomawhu.github.io/2020/04/11/ml/sgd/</id>
    <published>2020-04-11T18:41:08.000Z</published>
    <updated>2021-01-18T02:46:32.410Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="Machine Learning" scheme="https://jiaomawhu.github.io/tags/Machine-Learning/"/>
    
  </entry>
  
  <entry>
    <title>总结PAC Learning体系</title>
    <link href="https://jiaomawhu.github.io/2020/03/21/ml/PAC/"/>
    <id>https://jiaomawhu.github.io/2020/03/21/ml/PAC/</id>
    <published>2020-03-21T17:28:55.000Z</published>
    <updated>2021-01-18T02:46:22.275Z</updated>
    
    <content type="html"><![CDATA[<p>这个关于ML的系列中，我想总结下一些基础和经典的算法，包括理论，实现，以及面试点。这个系列主要参考的文献是[1,2,3]。</p><p>做为这个系列的第一篇，我们会讨论PAC Learning。它确定了理论体系，为之后的算法讨论奠定了基础。<a id="more"></a></p><p>既然说机器学习，那显然就是让机器能够自动学习到某种知识，模式，从而在之后能给出有意义的行为。学习算法有很多种，我们会在之后的篇章中讨论，在本篇中，我们首先确定一种算法训练以及预测的流程，或者说体系。</p><h2 id="ERM"><a href="#ERM" class="headerlink" title="ERM"></a>ERM</h2><p>不妨问自己一个问题，在日常生活中，我们是怎么学习，理解新知识，再应用的呢？假设说你要应付一个考试，而且还有一些往年的卷子。一个很直观的想法就是把这些卷子写了，再根据答案，看看自己哪里错了，从而订正理解有问题的点。这样，即使我们不知道真正的考试试卷，我们至少不会做错这些已经见过的题（希望如此）。</p><p>ERM (Empirical Risk Minimization) 就是这样一种根据经验的学习流程。假设说我们有training set $S$, 它是从distribution $D$中采样得来的。这些数据的真实label是由函数$f$所确定的。虽然我们的目标是找到算法$h_S$，使得其在$D$和$f$上的error最小，但是由于$D$和$f$往往是未知的，我们只能选择那些在training set上表现最好的算法。</p><p>正式来说，定义<em>training/empirical error</em>为</p><script type="math/tex; mode=display">L_S(h) = \frac{|\{i \in [m] : h(x_i) \ne y_i\}|}{m}</script><p>这里$m$是training set的大小，$[m]=\{1, \dots, m\}$。Empirical Risk Minimization就是找到算法$h$，其在$S$上的empirical error最小。</p><p>[1] Understanding Machine Learning: From Theory to Algorithms, Shai Shalev-Shwartz, Shai Ben-David<br>[2] 机器学习西瓜书，周志华<br>[3] 统计学习方法(第二版), 李航</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这个关于ML的系列中，我想总结下一些基础和经典的算法，包括理论，实现，以及面试点。这个系列主要参考的文献是[1,2,3]。&lt;/p&gt;
&lt;p&gt;做为这个系列的第一篇，我们会讨论PAC Learning。它确定了理论体系，为之后的算法讨论奠定了基础。
    
    </summary>
    
    
      <category term="Machine Learning" scheme="https://jiaomawhu.github.io/tags/Machine-Learning/"/>
    
  </entry>
  
  <entry>
    <title>二叉树经典题目整理</title>
    <link href="https://jiaomawhu.github.io/2019/04/01/cscore/tree/"/>
    <id>https://jiaomawhu.github.io/2019/04/01/cscore/tree/</id>
    <published>2019-04-01T20:37:23.000Z</published>
    <updated>2021-01-18T02:45:49.949Z</updated>
    
    <content type="html"><![CDATA[<p>本文整理了关于二叉树的总结与经典面试题<a id="more"></a></p><h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="二叉树的一些性质"><a href="#二叉树的一些性质" class="headerlink" title="二叉树的一些性质"></a>二叉树的一些性质</h2><ol><li>非空二叉树的叶子节点个数n0等于二叉节点的个数n2加1: n0=n2+1；</li><li>非空二叉树第$i$层最多有$2^{i-1}$个节点；</li><li>一个有h层的二叉数，最多有$2^{h}-1$个节点；</li><li>如果二叉树所有分支节点都有左孩子和右孩子节点，而且叶子节点都集中在二叉树的最下一层，则被称为<strong>满二叉树</strong>；</li><li>若二叉树最多只有最下面两层的节点的度数小于2，且最下面一层的叶子节点都依次排列在改层最左边的位置上，则被称为<strong>完全二叉树</strong>；</li><li>具有$n$个节点的完全二叉树高度为$\lfloor \log_2(n) \rfloor+1$。</li></ol><h2 id="递归遍历"><a href="#递归遍历" class="headerlink" title="递归遍历"></a>递归遍历</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preTranverse</span><span class="params">(TreeNode* node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    visit(node);</span><br><span class="line">    preTranverse(node-&gt;left);</span><br><span class="line">    preTranverse(node-&gt;right);</span><br><span class="line">&#125;<span class="comment">//此为先序遍历，后序和中序遍历改变后三行的顺序即可。</span></span><br></pre></td></tr></table></figure><h2 id="非递归遍历"><a href="#非递归遍历" class="headerlink" title="非递归遍历"></a>非递归遍历</h2><p>这里我参照了<a href="http://rudy-zhang.me/2015/10/10/%E6%89%BE%E5%B7%A5%E4%BD%9C%E6%80%BB%E7%BB%93-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%93%E9%A2%98-%E5%9F%BA%E7%A1%80/" target="_blank" rel="noopener">rudy</a>的总结：二叉树可以看成是对多有两个分支的有向图，递归遍历实际上是一种深度优先遍历，我们这里实际上是使用栈模拟深度优先遍历。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//中序</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; inorderTraversal(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode *&gt; s;</span><br><span class="line">        TreeNode * node = root;</span><br><span class="line">        <span class="keyword">while</span>(node! = <span class="literal">nullptr</span> || !s.empty())&#123;</span><br><span class="line">            <span class="keyword">if</span>(node)&#123;</span><br><span class="line">                s.push(node);</span><br><span class="line">                node = node-&gt;left;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                node = s.top();</span><br><span class="line">                s.pop();</span><br><span class="line">                res.push_back(node-&gt;val);</span><br><span class="line">                node = node-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//先序</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; preorderTraversal(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; s;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        TreeNode* node = root;</span><br><span class="line">        <span class="keyword">while</span>(!s.empty()||node)&#123;</span><br><span class="line">            <span class="keyword">if</span>(node)&#123;</span><br><span class="line">                res.push_back(node-&gt;val);</span><br><span class="line">                s.push(node);</span><br><span class="line">                node = node-&gt;left;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                node = s.top();</span><br><span class="line">                s.pop();</span><br><span class="line">                node = node-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//后序 写法1</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    TreeNode *n;</span><br><span class="line">    <span class="keyword">bool</span> isFirst;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(TreeNode *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    <span class="built_in">stack</span>&lt;MyNode*&gt; s;</span><br><span class="line">    TreeNode* node = root;</span><br><span class="line">    <span class="keyword">while</span>(node || !s.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(node)</span><br><span class="line">        &#123;</span><br><span class="line">            MyNode *myNode = <span class="keyword">new</span> MyNode();</span><br><span class="line">            myNode-&gt;n = node;</span><br><span class="line">            myNode-&gt;isFirst = <span class="literal">true</span>;</span><br><span class="line">            s.push(myNode);</span><br><span class="line">            node = node-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!s.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            MyNode *myNode = s.top();</span><br><span class="line">            s.pop();</span><br><span class="line">            <span class="keyword">if</span>(myNode-&gt;isFirst)</span><br><span class="line">            &#123;</span><br><span class="line">                myNode-&gt;isFirst = <span class="literal">false</span>;</span><br><span class="line">                s.push(myNode);</span><br><span class="line">                node = myNode-&gt;n-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//visit node</span></span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;myNode-&gt;n-&gt;val&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 后序 解法2 不定义新的数据结构</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; postorderTraversal(TreeNode* root) &#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="built_in">stack</span>&lt;TreeNode*&gt; s;</span><br><span class="line">    TreeNode* next = root, *node = <span class="literal">nullptr</span>;</span><br><span class="line">    s.push(root);</span><br><span class="line">    <span class="keyword">while</span>(!s.empty())&#123;</span><br><span class="line">        node = s.top();</span><br><span class="line">        <span class="keyword">if</span>((!node-&gt;left&amp;&amp;!node-&gt;right)||node-&gt;left==next||node-&gt;right==next)&#123;</span><br><span class="line">            res.push_back(node-&gt;val);</span><br><span class="line">            next = node;</span><br><span class="line">            s.pop();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;right) s.push(node-&gt;right);</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;left) s.push(node-&gt;left);</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Morris-遍历"><a href="#Morris-遍历" class="headerlink" title="Morris 遍历"></a>Morris 遍历</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 利用Threaded binary tree来做遍历，虽然空间和时间复杂度都没有提升，但是不需要使用栈或者递归</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; inorderTraversal(TreeNode *root) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> res;</span><br><span class="line">        TreeNode *cur, *pre;</span><br><span class="line">        cur = root;</span><br><span class="line">        <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!cur-&gt;left) &#123;</span><br><span class="line">                res.push_back(cur-&gt;val);</span><br><span class="line">                cur = cur-&gt;right;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                pre = cur-&gt;left;</span><br><span class="line">                <span class="keyword">while</span> (pre-&gt;right &amp;&amp; pre-&gt;right != cur) pre = pre-&gt;right;</span><br><span class="line">                <span class="keyword">if</span> (!pre-&gt;right) &#123;</span><br><span class="line">                    pre-&gt;right = cur;</span><br><span class="line">                    cur = cur-&gt;left;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    pre-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">                    res.push_back(cur-&gt;val);</span><br><span class="line">                    cur = cur-&gt;right;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="层次遍历"><a href="#层次遍历" class="headerlink" title="层次遍历"></a>层次遍历</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用队列模拟广度优先遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">levelOrder</span><span class="params">(TreeNode *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">queue</span>&lt;TreeNode *&gt; q;</span><br><span class="line">    TreeNode *node = root;</span><br><span class="line">    q.push(node);</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        node = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;node-&gt;val&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">        <span class="keyword">if</span>(node-&gt;left)</span><br><span class="line">            q.push(node-&gt;left);</span><br><span class="line">        <span class="keyword">if</span>(node-&gt;right)</span><br><span class="line">            q.push(node-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>剑指offer的<a href="https://github.com/JiaoMaWHU/jzoffer/blob/master/32.cpp" target="_blank" rel="noopener">第32题</a>就需要使用层次遍历：从上到下按层打印二叉树，同一层结点从左至右输出。还有延伸题，以之字形输出。</p><h2 id="二叉树中节点个数"><a href="#二叉树中节点个数" class="headerlink" title="二叉树中节点个数"></a>二叉树中节点个数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getNodeNum</span><span class="params">(TreeNode *root)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(root==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>+getNodeNum(root-&gt;left)+getNodeNum(root-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二叉树中叶子节点的个数"><a href="#二叉树中叶子节点的个数" class="headerlink" title="二叉树中叶子节点的个数"></a>二叉树中叶子节点的个数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getLeafNodeNum</span><span class="params">(TreeNode *root)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(root==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(root-&gt;left!=<span class="literal">nullptr</span>||root-&gt;right!=<span class="literal">nullptr</span>) </span><br><span class="line"><span class="keyword">return</span> getLeadNodeNum(root-&gt;left)+getLeadNodeNum(root-&gt;right);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二叉树第k层节点的个数"><a href="#二叉树第k层节点的个数" class="headerlink" title="二叉树第k层节点的个数"></a>二叉树第k层节点的个数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getKthFloorNum</span><span class="params">(TreeNode *root, <span class="keyword">int</span> target, <span class="keyword">int</span> <span class="built_in">floor</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(root==<span class="literal">nullptr</span>||<span class="built_in">floor</span>&gt;target) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(target==<span class="built_in">floor</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> getKthFloorNum(root-&gt;left, target, <span class="built_in">floor</span>+<span class="number">1</span>)+getKthFloorNum(root-&gt;right, target, <span class="built_in">floor</span>+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二叉树的深度"><a href="#二叉树的深度" class="headerlink" title="二叉树的深度"></a>二叉树的深度</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文整理了关于二叉树的总结与经典面试题
    
    </summary>
    
    
      <category term="Algorithms" scheme="https://jiaomawhu.github.io/tags/Algorithms/"/>
    
  </entry>
  
  <entry>
    <title>链表经典题目总结</title>
    <link href="https://jiaomawhu.github.io/2019/03/28/cscore/linkedlist/"/>
    <id>https://jiaomawhu.github.io/2019/03/28/cscore/linkedlist/</id>
    <published>2019-03-29T03:11:35.000Z</published>
    <updated>2021-01-18T02:45:11.572Z</updated>
    
    <content type="html"><![CDATA[<p>本文总结了关于链表的经典题目。<a id="more"></a></p><h1 id="首先是中总结的题目"><a href="#首先是中总结的题目" class="headerlink" title="首先是中总结的题目"></a>首先是中总结的题目</h1><h2 id="逆序打印链表"><a href="#逆序打印链表" class="headerlink" title="逆序打印链表"></a><a href="https://github.com/JiaoMaWHU/jzoffer/blob/master/6.cpp" target="_blank" rel="noopener">逆序打印链表</a></h2><p>用栈。</p><h2 id="在O-1-的时间里删除链表节点"><a href="#在O-1-的时间里删除链表节点" class="headerlink" title="在O(1)的时间里删除链表节点"></a><a href="https://github.com/JiaoMaWHU/jzoffer/blob/master/18-1.cpp" target="_blank" rel="noopener">在O(1)的时间里删除链表节点</a></h2><p>用下个节点覆盖本节点。</p><h2 id="删除链表中的重复节点"><a href="#删除链表中的重复节点" class="headerlink" title="删除链表中的重复节点"></a><a href="https://github.com/JiaoMaWHU/jzoffer/blob/master/18-2.cpp" target="_blank" rel="noopener">删除链表中的重复节点</a></h2><p>使用三个指针pre,head,next即可完成删除，只不过需要考虑删除的是否包括头结点这个问题。while的判断条件一开始我写成了while(p-&gt;next!=nullptr)，这样会造成错误，因为p有可能会被赋值成nullptr。另外，现行方法都没法满足删除后包括pre节点的重复判断，比如122111最后只会输出1，而不是nullptr。因此，在我的方法中，在删除重复的节点后，如果pre节点不为空，p节点会回退一步，这样就解决了这个问题。</p><h2 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a><a href="https://github.com/JiaoMaWHU/jzoffer/blob/master/24.cpp" target="_blank" rel="noopener">反转链表</a></h2><p>使用三个指针pre,head,next即可完成删除。</p><h2 id="合并两个排序的链表"><a href="#合并两个排序的链表" class="headerlink" title="合并两个排序的链表"></a><a href="https://github.com/JiaoMaWHU/jzoffer/blob/master/25.cpp" target="_blank" rel="noopener">合并两个排序的链表</a></h2><p>用循环可以写，但是递归写起来更方便。</p><h2 id="复杂链表的复制"><a href="#复杂链表的复制" class="headerlink" title="复杂链表的复制"></a><a href="https://github.com/JiaoMaWHU/jzoffer/blob/master/35.cpp" target="_blank" rel="noopener">复杂链表的复制</a></h2><ol><li>先把新的节点依次放到老节点后面；</li><li>更改random指针；</li><li>拆开。</li></ol><h2 id="链表中倒数第k个节点"><a href="#链表中倒数第k个节点" class="headerlink" title="链表中倒数第k个节点"></a><a href="https://github.com/JiaoMaWHU/jzoffer/blob/master/22.cpp" target="_blank" rel="noopener">链表中倒数第k个节点</a></h2><ol><li>让一个指针先走k-1步；</li><li>第二个指针从头跟着，两个一起走到头，第二个指针就指向倒数第k个节点。</li></ol><h2 id="链表中环的入口节点"><a href="#链表中环的入口节点" class="headerlink" title="链表中环的入口节点"></a><a href="https://github.com/JiaoMaWHU/jzoffer/blob/master/23.cpp" target="_blank" rel="noopener">链表中环的入口节点</a></h2><ol><li>用一个走两步的快指针和一个走一步的慢指针同时出发，能相遇就有环；</li><li>求环的长度l；</li><li>让一个指针先走l步，再和另外一个指向头的指针一起出发，相遇点就是入口节点。<br><strong>求链表的中间节点</strong>是上题的衍生。用同样的思路：用一个走两步的快指针和一个走一步的慢指针，这样，当快指针走到头过后，慢指针也就走到了中间节点。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">ReturnMiddleNode</span><span class="params">(ListNode* pHead)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pHead==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* f=pHead;</span><br><span class="line">        <span class="keyword">while</span>(f!=<span class="literal">nullptr</span>&amp;&amp;f-&gt;next!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            f=f-&gt;next-&gt;next;</span><br><span class="line">            pHead=pHead-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><h2 id="两个链表的第一个公共子节点"><a href="#两个链表的第一个公共子节点" class="headerlink" title="两个链表的第一个公共子节点"></a><a href="https://github.com/JiaoMaWHU/jzoffer/blob/master/53.cpp" target="_blank" rel="noopener">两个链表的第一个公共子节点</a></h2><ol><li>两个指针同时出发，最后相遇就有相交；</li><li>相交后，计算步数差；</li><li>按照步数差，让两个指针同步前进，相遇点就是第一个公共子节点。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文总结了关于链表的经典题目。
    
    </summary>
    
    
      <category term="Algorithms" scheme="https://jiaomawhu.github.io/tags/Algorithms/"/>
    
  </entry>
  
  <entry>
    <title>常用数据结构与算法整理</title>
    <link href="https://jiaomawhu.github.io/2019/03/23/cscore/search-sort/"/>
    <id>https://jiaomawhu.github.io/2019/03/23/cscore/search-sort/</id>
    <published>2019-03-23T23:28:35.000Z</published>
    <updated>2021-01-18T02:45:45.311Z</updated>
    
    <content type="html"><![CDATA[<p>本文参照<a href="https://github.com/kdn251/interviews" target="_blank" rel="noopener">这里</a>简单整理了常用的数据结构，搜索和排序算法。<a id="more"></a></p><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="字符串与数组（String-amp-Array）"><a href="#字符串与数组（String-amp-Array）" class="headerlink" title="字符串与数组（String &amp; Array）"></a>字符串与数组（String &amp; Array）</h2><p><strong>Permutation</strong>:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// next_permutation example</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;    // std::next_permutation</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::next_permutation(myints, myints+<span class="number">3</span>);</span><br><span class="line"><span class="built_in">std</span>::next_permutation(v.begin(), v.end());</span><br><span class="line"><span class="comment">// return true, if the function could rearrange the object as a lexicographicaly greater permutation, otherwise false</span></span><br><span class="line"><span class="comment">// std::prev_permutation is the same as next_permutation</span></span><br></pre></td></tr></table></figure></p><h2 id="链表（Linked-List）"><a href="#链表（Linked-List）" class="headerlink" title="链表（Linked List）"></a>链表（Linked List）</h2><p>首先是<strong>单向链表</strong>，一般定义如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode *next;</span><br><span class="line">    ListNode(<span class="keyword">int</span> x) :</span><br><span class="line">            val(x), next(<span class="literal">nullptr</span>) &#123;</span><br><span class="line">    &#125;<span class="comment">//列表初始化</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>一般会用到的操作有：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//新建</span></span><br><span class="line">ListNode *node = <span class="keyword">new</span> ListNode(<span class="number">1</span>);</span><br><span class="line">ListNode *node = oldNode;</span><br><span class="line"><span class="comment">//删除</span></span><br><span class="line"><span class="keyword">delete</span> node;</span><br><span class="line"><span class="comment">//指向下个链表</span></span><br><span class="line">node=node-&gt;next;</span><br><span class="line"><span class="comment">//头插法</span></span><br><span class="line">ListNode *node = <span class="keyword">new</span> ListNode(<span class="number">1</span>);</span><br><span class="line">node-&gt;next=headNode-&gt;next;</span><br><span class="line">headNode-&gt;next=node;</span><br><span class="line"><span class="comment">//尾插法</span></span><br><span class="line">ListNode *node = <span class="keyword">new</span> ListNode(<span class="number">1</span>);</span><br><span class="line">lastNode-&gt;next=node;</span><br><span class="line">lastNode=node;</span><br></pre></td></tr></table></figure></p><p>然后是<strong>双向链表</strong>，由于双向链表基本操作与单向链表相似，故不列出：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode *next;</span><br><span class="line">    ListNode *front;</span><br><span class="line">    ListNode(<span class="keyword">int</span> x) :</span><br><span class="line">            val(x), next(<span class="literal">nullptr</span>), front(<span class="literal">nullptr</span>) &#123;</span><br><span class="line">    &#125;<span class="comment">//列表初始化</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>In STL, we generally use std::list.<br>Common operations of list are as follows.<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span> l;</span><br><span class="line">l.begin()</span><br><span class="line">l.end()</span><br><span class="line">l.rbegin() <span class="comment">// reverse</span></span><br><span class="line">l.rend() <span class="comment">// reverse</span></span><br><span class="line">l.front(); l.end();</span><br><span class="line">l.push_front(); l.push_back();</span><br><span class="line">l.pop_front(); l.pop_back();</span><br><span class="line">l.splice(target_list::iterator, target_list, your_iterator);</span><br><span class="line">l.erase(iterator);</span><br></pre></td></tr></table></figure></p><blockquote><p>关于链表的经典问题总结在了这里： <a href="/2019/03/28/cscore/linkedlist/" title="链表经典题目总结">链表经典题目总结</a>。</p></blockquote><h2 id="栈与队列（Stack-amp-Queue）"><a href="#栈与队列（Stack-amp-Queue）" class="headerlink" title="栈与队列（Stack &amp; Queue）"></a>栈与队列（Stack &amp; Queue）</h2><p>这两种数据结构一般都是用STL的，定义如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br></pre></td></tr></table></figure></p><p>常用操作如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">s.empty()<span class="comment">//如果栈为空返回true，否则返回false  </span></span><br><span class="line">s.size()<span class="comment">//返回栈中元素的个数  </span></span><br><span class="line">s.pop()<span class="comment">//删除栈顶元素但不返回其值  </span></span><br><span class="line">s.top()<span class="comment">//返回栈顶的元素，但不删除该元素  </span></span><br><span class="line">s.push(X)<span class="comment">//在栈顶压入新元素 ，参数X为要压入的元素</span></span><br><span class="line"></span><br><span class="line">q.empty()<span class="comment">// 如果队列为空返回true，否则返回false  </span></span><br><span class="line">q.size() <span class="comment">// 返回队列中元素的个数  </span></span><br><span class="line">q.pop()  <span class="comment">//删除队列首元素但不返回其值  </span></span><br><span class="line">q.front()  <span class="comment">// 返回队首元素的值，但不删除该元素  </span></span><br><span class="line">q.push(X) <span class="comment">//在队尾压入新元素 ，X为要压入的元素</span></span><br><span class="line">q.back() <span class="comment">//返回队列尾元素的值，但不删除该元素</span></span><br></pre></td></tr></table></figure></p><p>Deque的常规api如下:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">q.push_back();</span><br><span class="line">q.push_front();</span><br><span class="line">q.pop_back();</span><br><span class="line">q.pop_front();</span><br><span class="line">q.front();</span><br><span class="line">q.back();</span><br></pre></td></tr></table></figure></p><p>同时也整理下pair&lt;,&gt;这种用法：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">stack</span>&lt;pair&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt; &gt; s;</span><br><span class="line">s.push(make_pair(string1,<span class="number">1</span>));</span><br><span class="line">pair&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt; p = s.top();</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;p.first&lt;&lt;p.second;</span><br></pre></td></tr></table></figure></p><h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><h3 id="二叉树-Binary-Tree-："><a href="#二叉树-Binary-Tree-：" class="headerlink" title="二叉树 (Binary Tree)："></a>二叉树 (Binary Tree)：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.数组存储,n节点的左右子树为2n,2n+1</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Tree[MaxSize];</span><br><span class="line"><span class="comment">//2.链表存储</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode* left;</span><br><span class="line">    TreeNode* right;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> x):val(x), left(<span class="literal">NULL</span>), right(<span class="literal">NULL</span>)&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>二叉树有很多常用的操作，比如前、中、后序遍历，层次遍历，求深度，子节点的公共祖先，由于篇幅过长，在<a href="/2019/04/01/cscore/tree/" title="二叉树经典题目整理">二叉树经典题目整理</a>进行了专门的总结。</p><h3 id="二叉查找树-Binary-Search-Tree-BST"><a href="#二叉查找树-Binary-Search-Tree-BST" class="headerlink" title="二叉查找树 Binary Search Tree(BST)"></a>二叉查找树 Binary Search Tree(BST)</h3><ol><li>For a BST node, all values in its left child tree (if has) are less than it, while values in its right child tree (if has) are bigger then it.</li><li>Every node has a unique value.</li></ol><p>从array构建BST:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// use binary search to build the BST</span></span><br><span class="line"><span class="function">TreeNode* <span class="title">sortedArrayToBST</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> buildBST(<span class="number">0</span>, nums.size()<span class="number">-1</span>, nums);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode* <span class="title">buildBST</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> e, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s&gt;e)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode* node = <span class="keyword">new</span> TreeNode(nums[(s+e)/<span class="number">2</span>]);</span><br><span class="line">    node-&gt;left = buildBST(s, (s+e)/<span class="number">2</span><span class="number">-1</span>, nums);</span><br><span class="line">    node-&gt;right = buildBST((s+e)/<span class="number">2</span>+<span class="number">1</span>, e, nums);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>BST插入节点<br>BST删除节点</p><h3 id="二叉平衡树-Binary-Balanced-Tree"><a href="#二叉平衡树-Binary-Balanced-Tree" class="headerlink" title="二叉平衡树 Binary Balanced Tree"></a>二叉平衡树 Binary Balanced Tree</h3><h4 id="红黑树-Red-black-Tree"><a href="#红黑树-Red-black-Tree" class="headerlink" title="红黑树 Red-black Tree"></a>红黑树 Red-black Tree</h4><h3 id="Tire-Tree"><a href="#Tire-Tree" class="headerlink" title="Tire Tree"></a>Tire Tree</h3><h3 id="二叉索引树-Binary-Indexed-Tree"><a href="#二叉索引树-Binary-Indexed-Tree" class="headerlink" title="二叉索引树 Binary Indexed Tree"></a>二叉索引树 Binary Indexed Tree</h3><h3 id="线段树-Segment-Tree"><a href="#线段树-Segment-Tree" class="headerlink" title="线段树 Segment Tree"></a>线段树 Segment Tree</h3><h2 id="并查集-Union-Find"><a href="#并查集-Union-Find" class="headerlink" title="并查集 Union-Find"></a>并查集 Union-Find</h2><h3 id="Union"><a href="#Union" class="headerlink" title="Union"></a>Union</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A function that does union of two sets of x and y </span></span><br><span class="line"><span class="comment">// (uses union by rank) </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Union</span><span class="params">(struct subset subsets[], <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">int</span> xroot = find(subsets, x); </span><br><span class="line">    <span class="keyword">int</span> yroot = find(subsets, y); </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// Attach smaller rank tree under root of high rank tree </span></span><br><span class="line">    <span class="comment">// (Union by Rank) </span></span><br><span class="line">    <span class="keyword">if</span> (subsets[xroot].rank &lt; subsets[yroot].rank) </span><br><span class="line">        subsets[xroot].parent = yroot; </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (subsets[xroot].rank &gt; subsets[yroot].rank) </span><br><span class="line">        subsets[yroot].parent = xroot; </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// If ranks are same, then make one as root and increment </span></span><br><span class="line">    <span class="comment">// its rank by one </span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123; </span><br><span class="line">        subsets[yroot].parent = xroot; </span><br><span class="line">        subsets[xroot].rank++; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Find"><a href="#Find" class="headerlink" title="Find"></a>Find</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// includes path compressing: </span></span><br><span class="line"><span class="comment">// while finding the parent of node A, mark the root as a A's direct parent</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(struct subset subsets[], <span class="keyword">int</span> i)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="comment">// find root and make root as parent of i (path compression) </span></span><br><span class="line">    <span class="keyword">if</span> (subsets[i].parent != i) </span><br><span class="line">        subsets[i].parent = find(subsets, subsets[i].parent); </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> subsets[i].parent; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="堆-Heap"><a href="#堆-Heap" class="headerlink" title="堆 Heap"></a>堆 Heap</h2><p>A Heap is a specialized tree based structure data structure that satisfies the heap property:</p><p><em>if A is a parent node of B, then the key (the value) of node A is ordered with respect to the key of node B with the same ordering applying across the entire heap.</em></p><p>For a <strong>max-heap</strong>, the value of a node is bigger or equal than all of its children’s values. A <strong>min-heap</strong> has the opposite rule.</p><p>Time Complexity:</p><ul><li>Access Max / Min: O(1)</li><li>Insert: O(log(n))</li><li>Remove Max / Min: O(log(n))</li></ul><p>In C++, we use <strong>priority_queue</strong> as a heap, and common operations are as follows.<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.Min Heap</span></span><br><span class="line">priority_queue &lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt; &gt; pq;</span><br><span class="line"><span class="comment">// The expression comp(a,b), where comp is an object of this type and a and b are elements in the container, </span></span><br><span class="line"><span class="comment">// shall return true if a is considered to go before b (like a...b in vector) in the strict weak ordering the function defines.</span></span><br><span class="line"><span class="comment">// But because the priority queue outputs largest elements first, the elements that "come before" are actually output last.</span></span><br><span class="line"><span class="comment">// A easy way to remember: greater cmp -&gt; min heap</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.Max Heap</span></span><br><span class="line">priority_queue &lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; pq;</span><br><span class="line"></span><br><span class="line"><span class="comment">// common methods</span></span><br><span class="line">pq.push(x);</span><br><span class="line">pq.top(x);</span><br><span class="line">pq.pop(x);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.We can also use make_heap() function in STL to convert a range in a container to a heap.</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1 = &#123;<span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">25</span>, <span class="number">15</span>&#125;; </span><br><span class="line">make_heap(v1.begin(), v1.end()); <span class="comment">// front() will be the max node</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. To write a customized compare function, follow this:</span></span><br><span class="line"><span class="keyword">auto</span> cmp = [](<span class="keyword">const</span>&amp; <span class="keyword">int</span> n1, <span class="keyword">const</span>&amp; <span class="keyword">int</span> n2)&#123;</span><br><span class="line">    <span class="keyword">return</span> n1&gt;n2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">priority_queue&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, <span class="keyword">int</span>, <span class="keyword">decltype</span>(cmp)&gt; v(cmp); <span class="comment">// customized min heap</span></span><br></pre></td></tr></table></figure></p><h2 id="Hash-Table"><a href="#Hash-Table" class="headerlink" title="Hash Table"></a>Hash Table</h2><p>我们一般用<strong>Unordered_set</strong>, 来当做<strong>hash table</strong>使用。</p><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p>我们可以选择<strong>ordered_map</strong>或者<strong>unordered_set</strong>.</p><ul><li><strong>Ordered_map</strong>使用红黑树实现，插入和删除都是<code>O(log n)</code>.</li><li><strong>Unordered_map</strong>使用hash链表实现, 插入和删除时O(K), K是hash bucket下element个数的平均值，一般视为<code>O(1)</code>.</li></ul><h1 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h1><h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><p>在这里补充下二分查找的两种写法。循环写法：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//给定一个有序的数组，查找 value 是否在数组中，不存在返回 - 1。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BinarySearch</span><span class="params">(<span class="keyword">int</span> <span class="built_in">array</span>[], <span class="keyword">int</span> n, <span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left=<span class="number">0</span>, right = n<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">        midde=left+((right-left)&gt;&gt;<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">array</span>[middle]&gt;value)&#123;</span><br><span class="line">        right=middle<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">array</span>[middle]&lt;value)&#123;</span><br><span class="line">        left=middle+<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">return</span> middle;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>关于更多的二分查找的变种可以参考<a href="https://subetter.com/algorithm/binary-search.html" target="_blank" rel="noopener">这里</a>。递归写法：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BinarySearch</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x&gt;y)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">int</span> middle = x + ((y-x)&gt;&gt;<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">array</span>[middle]&gt;value)&#123;</span><br><span class="line"><span class="keyword">return</span> BinarySearch(x,middle<span class="number">-1</span>,value);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">array</span>[middle]&lt;value)&#123;</span><br><span class="line"><span class="keyword">return</span> BinarySearch(middle+<span class="number">1</span>,y,value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> middle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><p><strong>排序算法稳定性定义</strong>：排序前后两个相等的数相对位置不变，则算法稳定。<br><strong>稳定性的好处</strong>：从一个键上排序，然后再从另一个键上排序，第一个键排序的结果可以为第二个键排序所用。<br>Generally, we use std::sort() to sort container in c++. The default sort is in increasing order. If we want decreasing order, we use, for example:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">sort(v.begin(), v.end(), greater&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line"><span class="comment">// the cmp argument means using the boolean to determine if the first argument in sorting should be go before the second one.</span></span><br><span class="line"><span class="comment">// decreasing -&gt; if the fist is greater than the second, the first goes ahead in the vector.</span></span><br></pre></td></tr></table></figure></p><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p><strong>1.直接插入</strong><br>从小到大排序：将数组左侧划分为有序区，右侧划分为无序区。每次将无序区的第一个元素插入到有序区的相应位置，同时增大有序区的大小。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertsort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> N)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp=a[i]; </span><br><span class="line">        <span class="keyword">int</span> j;</span><br><span class="line">        <span class="keyword">for</span> (j = i; j&gt;<span class="number">0</span> &amp;&amp; tmp&lt;a[j<span class="number">-1</span>]; --j)&#123;</span><br><span class="line">            a[j]=a[j<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        a[j]=tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>2.希尔排序</strong><br>希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shellsort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> N)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> incre=N/<span class="number">2</span>; incre&gt;<span class="number">0</span>; incre/=<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=incre; i&lt;N; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> tmp=a[i]; <span class="keyword">int</span> j;</span><br><span class="line">            <span class="keyword">for</span>(j=i; j&gt;=incre &amp;&amp; tmp&lt;a[j-incre]; j-=incre)&#123;</span><br><span class="line">                a[j]=a[j-incre];</span><br><span class="line">            &#125;</span><br><span class="line">            a[j]=tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p><strong>1.选择排序</strong><br>从小到大排序：将数组左侧划分为有序区，右侧划分为无序区。每次从无序区选择最小的元素与开头交换，继而增大有序区大小。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">selectsort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> N)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp=a[i];<span class="keyword">int</span> min=tmp;<span class="keyword">int</span> min_j;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; N; ++j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[min_j]&lt;min) min_j=j;</span><br><span class="line">        &#125;</span><br><span class="line">        a[i]=a[min_j];</span><br><span class="line">        a[min_j]=tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>2.堆排序</strong><br>堆排序的基本思想是：将待排序序列构造成一个大顶堆，此时，整个序列的最大值就是堆顶的根节点。将其与末尾元素进行交换，此时末尾就为最大值。然后将剩余n-1个元素重新构造成一个堆，这样会得到n个元素的次小值。如此反复执行，便能得到一个有序序列了<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">percDown</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> i, <span class="keyword">int</span> N)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = a[i], child;</span><br><span class="line">    <span class="keyword">for</span>(; <span class="number">2</span> * i + <span class="number">1</span> &lt; N; i = child)</span><br><span class="line">    &#123;</span><br><span class="line">        child = <span class="number">2</span> * i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(child + <span class="number">1</span> &lt; N &amp;&amp; a[child] &lt; a[child + <span class="number">1</span>])</span><br><span class="line">            child++;</span><br><span class="line">        <span class="keyword">if</span>(temp &lt; a[child])</span><br><span class="line">            a[i] = a[child];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    a[i] = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> N)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = N / <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        percDown(a, i, N);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = N<span class="number">-1</span>; i &gt; <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = a[i];</span><br><span class="line">        a[i] = a[<span class="number">0</span>];</span><br><span class="line">        a[<span class="number">0</span>] = temp;</span><br><span class="line">        percDown(a, <span class="number">0</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="交换排序"><a href="#交换排序" class="headerlink" title="交换排序"></a>交换排序</h2><p><strong>1.快速排序</strong><br>原理：不断寻找一个序列的中点，然后对中点左右的序列递归的进行排序，直至全部序列排序完成，使用了分治的思想。<br>1．先从数列中取出一个数作为基准数。<br>2．分区过程，将比这个数大的数全放到它的右边，小于或等于它的数全放到它的左边。<br>3．再对左右区间重复第二步，直到各区间只有一个数。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quicksort</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> e, <span class="keyword">int</span> a[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=s, j=e, tmp;</span><br><span class="line">    <span class="keyword">if</span>(s&gt;=e) <span class="keyword">return</span>;</span><br><span class="line">    tmp = a[s];</span><br><span class="line">    <span class="keyword">while</span>(i!=j)&#123;</span><br><span class="line">        <span class="keyword">while</span>(j&gt;i &amp;&amp; tmp &lt;= a[j]) j--;</span><br><span class="line">        a[i]=a[j];</span><br><span class="line">        <span class="keyword">while</span>(i&lt;j &amp;&amp; tmp &gt;= a[i]) i++;</span><br><span class="line">        a[j]=a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    a[i]=tmp;</span><br><span class="line">    quicksort(s,i<span class="number">-1</span>,a[]);</span><br><span class="line">    quicksort(i+<span class="number">1</span>,e,a[]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>2.冒泡排序</strong><br>原理：将序列划分为无序和有序区，不断通过交换较大元素至无序区尾完成排序。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> N)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N - i - <span class="number">1</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[j] &gt; a[j+<span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = a[j];</span><br><span class="line">                a[j] = a[j+<span class="number">1</span>];</span><br><span class="line">                a[j+<span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> temp[], <span class="keyword">int</span> left, <span class="keyword">int</span> mid, <span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left &lt; right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> lpos = left, lend = mid;</span><br><span class="line">        <span class="keyword">int</span> rpos = mid + <span class="number">1</span>, rend = right;</span><br><span class="line">        <span class="keyword">int</span> tpos = left;</span><br><span class="line">        <span class="keyword">while</span>(lpos &lt;= lend &amp;&amp; rpos &lt;= rend)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[lpos] &lt;= a[rpos])</span><br><span class="line">                temp[tpos++] = a[lpos++];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                temp[tpos++] = a[rpos++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(lpos &lt;= lend)</span><br><span class="line">            temp[tpos++] = a[lpos++];</span><br><span class="line">        <span class="keyword">while</span>(rpos &lt;= rend)</span><br><span class="line">            temp[tpos++] = a[rpos++];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = left; i &lt;= right; i++)</span><br><span class="line">            a[i] = temp[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSortCore</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> temp[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left &lt; right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        mergeSortCore(a, temp, left, mid);</span><br><span class="line">        mergeSortCore(a, temp, mid+<span class="number">1</span>, right);</span><br><span class="line">        merge(a, temp, left, mid, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> N)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *temp = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">    mergeSortCore(a, temp, <span class="number">0</span>, N<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">delete</span> [] temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><h2 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h2><h2 id="算法稳定性与性能分析"><a href="#算法稳定性与性能分析" class="headerlink" title="算法稳定性与性能分析"></a>算法稳定性与性能分析</h2><p>各个排序算法总结如下图所示（来源于网络）：<br><img src="/images/sort.jpg" alt=""></p><h1 id="图算法"><a href="#图算法" class="headerlink" title="图算法"></a>图算法</h1><h2 id="深度与广度优先算法"><a href="#深度与广度优先算法" class="headerlink" title="深度与广度优先算法"></a>深度与广度优先算法</h2><h2 id="Dijkstra-amp-Bellman-Ford-amp-Floyd-算法"><a href="#Dijkstra-amp-Bellman-Ford-amp-Floyd-算法" class="headerlink" title="Dijkstra &amp; Bellman-Ford &amp; Floyd 算法"></a>Dijkstra &amp; Bellman-Ford &amp; Floyd 算法</h2><h2 id="Prim-amp-Kruskal-算法"><a href="#Prim-amp-Kruskal-算法" class="headerlink" title="Prim &amp; Kruskal 算法"></a>Prim &amp; Kruskal 算法</h2><h1 id="最大流"><a href="#最大流" class="headerlink" title="最大流"></a>最大流</h1><h1 id="Hash算法"><a href="#Hash算法" class="headerlink" title="Hash算法"></a>Hash算法</h1>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文参照&lt;a href=&quot;https://github.com/kdn251/interviews&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这里&lt;/a&gt;简单整理了常用的数据结构，搜索和排序算法。
    
    </summary>
    
    
      <category term="Algorithms" scheme="https://jiaomawhu.github.io/tags/Algorithms/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer</title>
    <link href="https://jiaomawhu.github.io/2019/03/10/cscore/jzoffer/"/>
    <id>https://jiaomawhu.github.io/2019/03/10/cscore/jzoffer/</id>
    <published>2019-03-11T03:27:18.000Z</published>
    <updated>2021-01-18T02:45:03.227Z</updated>
    
    <content type="html"><![CDATA[<p>剑指offer刷题的记录与总结<a id="more"></a></p><h1 id=""><a href="#" class="headerlink" title=""></a></h1><h1 id="-1"><a href="#-1" class="headerlink" title=""></a></h1><p><br></p><h1 id="题三-数组中的重复数字"><a href="#题三-数组中的重复数字" class="headerlink" title="题三 数组中的重复数字"></a>题三 数组中的重复数字</h1><h2 id="题目一"><a href="#题目一" class="headerlink" title="题目一"></a>题目一</h2><p>要求算法能在时间复杂度O(n)，空间复杂度O(1)的情况下，输出一个数组中的重复数字。我们很容易想到一个时间复杂度O(n)，空间复杂度O(n)的做法。如何完成空间复杂度为O(1)? </p><p>题解：</p><ol><li>顺序遍历数组，如果下标i和值m相同，说明这个位置没有重复，继续向后。</li><li>如果遇到了，下标i和值m不同，那么比较m和下标为m的值是否相等，如果相等，说明m这个值重复。</li><li>如果不相等，就把m和下标为m的值交换，这样在后面如果又遇到这个值，就可以进行第2步，从而判断是否重复。</li></ol><h2 id="题目二"><a href="#题目二" class="headerlink" title="题目二"></a>题目二</h2><p>一个长度为n+1的数组，其中数字的范围为1-n，故肯定会有重复。请找出任意一个重复值，但不得改变数组。<br>很显然，有一个时间复杂度O(n)，空间复杂度O(n)的解法。但，如果要求空间复杂度为O(1)呢？</p><p>题解：<br>使用二分查找的思路，对每一半$\phi$的上标1-m，遍历总数组一遍，判断数组中的数属于1-m的总数，是否大于m，若大于，下次从这里开始二分，否则从另一半开始二分。</p><p>此方法，空间复杂度O(1)，但空间复杂度O(nlog(n))，所以属于牺牲时间换空间。还有另外一种解，归并排序，然后再遍历一遍，判断下一个是否与上一个重复，空间时间复杂度均与上面的方法相同。</p><h1 id="题四-二维数组中的查找"><a href="#题四-二维数组中的查找" class="headerlink" title="题四 二维数组中的查找"></a>题四 <a href="https://github.com/JiaoMaWHU/jzoffer/blob/master/4.cpp" target="_blank" rel="noopener">二维数组中的查找</a></h1><p>在二维数组中，每一行都按照从左到右递增的顺序，每一列按照从上到下递增的顺序。查找是否存在，一个数n。</p><p>题解：很显然，应该从数组第一行的最后一个数字开始考虑，如果此数字就已经大于n，它所在的列是不可能包含n的。若大于n，则考虑这一列前面的列。若小于n，向这一列下方考虑：若遇见n，则结束；若遇到了x个比n小的数后，发现一个比n大的数，则在接下来的遍历中，不需要考虑，x行及之前行中的数了。若没有遇到比n大的数，则此数组没有n。</p><h1 id="题五-替换空格"><a href="#题五-替换空格" class="headerlink" title="题五 替换空格"></a>题五 <a href="https://github.com/JiaoMaWHU/jzoffer/blob/master/5.cpp" target="_blank" rel="noopener">替换空格</a></h1><p>前提知识：用同样的内容初始化数组和指针，会得到不同的数组和相同的指针指向，因为指针是由常量字符串初始化得到的。</p><p>将字符串中的空格换为3个其他字符。</p><p>题解：显然可以新建一个字符串。如果要求在原字符串上修改，则应该先扫描一遍，然后根据对应的移动数，进行字符的移动。同样在遇到，合并两个数组到其中一个这样的题目上时，我们也应该采用从后向前的方法，来减少移动次数。</p><h1 id="题六-打印链表"><a href="#题六-打印链表" class="headerlink" title="题六 打印链表"></a>题六 <a href="https://github.com/JiaoMaWHU/jzoffer/blob/master/6.cpp" target="_blank" rel="noopener">打印链表</a></h1><p>反向输出链表，没啥好讲的。</p><h1 id="题七-重建二叉树"><a href="#题七-重建二叉树" class="headerlink" title="题七 重建二叉树"></a>题七 <a href="https://github.com/JiaoMaWHU/jzoffer/blob/master/7.cpp" target="_blank" rel="noopener">重建二叉树</a></h1><p>根据前序和中序序列构建二叉树。</p><p>题解：可按照递归的方法，每次通过限定index范围来构建左子树和右子树。</p><p>这里比较容易错的地方是：1.递归结束的条件：当前前序序列中无其他节点；2.构建左子树要满足：此根节点左侧还有点；3.构建右子树要满足：此根节点右侧还有点。</p><h1 id="题八-二叉树的下一个节点"><a href="#题八-二叉树的下一个节点" class="headerlink" title="题八 二叉树的下一个节点"></a>题八 二叉树的下一个节点</h1><p>给定一个二叉树和一个节点，找到中序序列中其下一个节点。简单分为三种情况分析，没啥好说的。</p><h1 id="题九-用两个栈实现队列"><a href="#题九-用两个栈实现队列" class="headerlink" title="题九 用两个栈实现队列"></a>题九 <a href="https://github.com/JiaoMaWHU/jzoffer/blob/master/9.cpp" target="_blank" rel="noopener">用两个栈实现队列</a></h1><p>很显然，用一个栈来存储输入，一个栈来控制输出。当要求输出时，先判断输出栈是否为空，如果为空，则把输入栈的内容全部pop到输出栈里面。这样输出就和队列相似了。</p><p>用两个队列来实现栈也很简单，在每次pop的时候，把除了最后一个值以外的值pop到另一个队列中，然后把最后一个值输出即可。</p><h1 id="题十-斐波那契数列"><a href="#题十-斐波那契数列" class="headerlink" title="题十 斐波那契数列"></a>题十 <a href="https://github.com/JiaoMaWHU/jzoffer/blob/master/10.cpp" target="_blank" rel="noopener">斐波那契数列</a></h1><p>普通要求的斐波那契数列递归写法很简单，但是效率很低，是以n的指数级展开。我们很显然可以想到一个从0向后顺序算下去的方法，时间复杂度为O(n)。很好，但是，书上还给出了一种O(log(n))的方法，一个斐波那契数列的矩阵乘法性质。具体解释可以看<a href="https://www.cnblogs.com/simplc/p/6742928.html" target="_blank" rel="noopener">这里</a>。</p><p>书中提到了青蛙跳台阶问题。如果一个青蛙每次可以跳1或2次，那么跳到第n个台阶有多少种跳法？令f(n)为跳n个台阶的方法，有f(n)=f(n-1)+f(n-2)，因为这正好和可以跳的次数符合。但是此问题的f(0)=1。此外，如果每次青蛙能跳任意台阶呢？我们易证$f(n)=2^{n-1}$。</p><p>另外，书中还提到了矩形填充的问题，也是一个斐波那契数列问题。</p><h1 id="题十一-旋转数组的最小数字"><a href="#题十一-旋转数组的最小数字" class="headerlink" title="题十一 旋转数组的最小数字"></a>题十一 <a href="https://github.com/JiaoMaWHU/jzoffer/blob/master/11.cpp" target="_blank" rel="noopener">旋转数组的最小数字</a></h1><p>这题只要把三种情况列出来就知道怎么写了。也趁这个机会复习了下搜索和排序。</p><h1 id="题十二-矩阵中的路劲"><a href="#题十二-矩阵中的路劲" class="headerlink" title="题十二 矩阵中的路劲"></a>题十二 <a href="https://github.com/JiaoMaWHU/jzoffer/blob/master/12.cpp" target="_blank" rel="noopener">矩阵中的路劲</a></h1><p>在一个二维数组中找到一个符合指定字符串的路劲，要求不能重复使用一个点。</p><p>这题很显然使用dfs来做。复习到的知识点：动态初始化二维数组。我把[row*cols+col]写成了[row*rows+col]，调试了老半天也过不了，sad。。。</p><h1 id="题十三-机器人的运动范围"><a href="#题十三-机器人的运动范围" class="headerlink" title="题十三 机器人的运动范围"></a>题十三 <a href="https://github.com/JiaoMaWHU/jzoffer/blob/master/13.cpp" target="_blank" rel="noopener">机器人的运动范围</a></h1><p>也是个很简单的dfs，没啥可说的。</p><h1 id="题十四-剪绳子"><a href="#题十四-剪绳子" class="headerlink" title="题十四 剪绳子"></a>题十四 剪绳子</h1><p>有一根n长的绳子，可以把它剪成任意的m段，怎样剪能使得他们的乘积最大？书中首先给出了动态规划的做法。动态规划做法的关键在于，由于递归做法(f(n)=max(f(i)*f(n-i)))会有很多的子问题，所以我们从下到上开始，从而得到f(n)。书中的第二种做法是最优贪心：当剩余长度大于4时尽可能剪长度为3的绳子，否则剪长度为2的绳子。为什么这种贪心能达到最优呢？</p><p>我们首先易得$n&lt;=4$时最优解法。当$n&gt;=5$时，令$g(n)=a\times(n-a)&gt;n$，得到$(a-1)n-a^2&gt;0$，显然为了使得不等式成立，有$a&gt;1$。因此$g(n)$为递增函数，最小值在$n=5$获得，可得$5(a-1)-a^2&gt;0$，解此方程式得$a=2,3$。又因为$2(n-1)&lt;=3(n-3)$，所以我们可知，当绳子长度长于4时，我们尽量剪3长度的绳子，就可得到最优解。</p><p>从这一题我们可以得知，如果一个最优解问题可以划分成为若干个子问题，且子问题中还有重叠的更小的子问题，我们就可以考虑用动态规划并从下向上求解。我们也可以尝试使用贪心算法，但是要给出最优的证明。</p><h1 id="题十五-位运算"><a href="#题十五-位运算" class="headerlink" title="题十五 位运算"></a>题十五 <a href="https://github.com/JiaoMaWHU/jzoffer/blob/master/15.cpp" target="_blank" rel="noopener">位运算</a></h1><p>输出一个数二进制中的所有1。要考虑到负数移位的死循环问题，所以书中提出了一种移位相与的常规写法。然后又写了一个相减再与的写法，用到了这样一个思想：把一个整数减去1之后再和原来的数做位与运算，结果相当于把原来的数的最右边的1变成0。感觉在中很难随时想到，还是常规写法好想。</p><h1 id="题十六-数值的整数次方"><a href="#题十六-数值的整数次方" class="headerlink" title="题十六 数值的整数次方"></a>题十六 <a href="https://github.com/JiaoMaWHU/jzoffer/blob/master/16.cpp" target="_blank" rel="noopener">数值的整数次方</a></h1><p>这题主要是考察代码的鲁棒性。应该从三个方面考察：功能测试，边界测试，错误测试。像是这题应该考虑底数为0指数为负的错误情况，指数为负数的边界情况，以及功能测试。折半求指数乘积的方法能够降低算法的复杂度。</p><h1 id="题十七-打印从1到最大n位数"><a href="#题十七-打印从1到最大n位数" class="headerlink" title="题十七 打印从1到最大n位数"></a>题十七 打印从1到最大n位数</h1><p>这题要注意大数问题，可以使用字符串来实现。同时一个输出全排列的方法可以提高算法的效率。</p><h1 id="题十八-删除链表的节点"><a href="#题十八-删除链表的节点" class="headerlink" title="题十八 删除链表的节点"></a>题十八 删除链表的节点</h1><h2 id="题目一-在O-1-的时间里删除链表节点"><a href="#题目一-在O-1-的时间里删除链表节点" class="headerlink" title="题目一 在O(1)的时间里删除链表节点"></a>题目一 <a href="https://github.com/JiaoMaWHU/jzoffer/blob/master/18-1.cpp" target="_blank" rel="noopener">在O(1)的时间里删除链表节点</a></h2><p>在O(1)的时间里删除一个指针节点，给定头指针和该指针节点。<br>我们可以用当前指针节点代替下一个节点，然后删除下个节点即可完成O(1)的做法，只是当我们要删除的是最后一个节点的时候，只能先遍历到先前节点，然后再进行删除。</p><h2 id="题目二-删除链表中的重复节点"><a href="#题目二-删除链表中的重复节点" class="headerlink" title="题目二 删除链表中的重复节点"></a>题目二 <a href="https://github.com/JiaoMaWHU/jzoffer/blob/master/18-2.cpp" target="_blank" rel="noopener">删除链表中的重复节点</a></h2><p>使用三个指针pre,head,next即可完成删除，只不过需要考虑删除的是否包括头结点这个问题。while的判断条件一开始我写成了while(p-&gt;next!=nullptr)，这样会造成错误，因为p有可能会被赋值成nullptr。另外，现行方法都没法满足删除后包括pre节点的重复判断，比如122111最后只会输出1，而不是nullptr。因此，在我的方法中，在删除重复的节点后，如果pre节点不为空，p节点会回退一步，这样就解决了这个问题。</p><h1 id="题十九-正则表达式匹配"><a href="#题十九-正则表达式匹配" class="headerlink" title="题十九 正则表达式匹配"></a>题十九 <a href="https://github.com/JiaoMaWHU/jzoffer/blob/master/19.cpp" target="_blank" rel="noopener">正则表达式匹配</a></h1><p>这一题很有意思，用状态机模式来完成了正则表达式，值得研究。</p><h1 id="题二十-先留在这里"><a href="#题二十-先留在这里" class="headerlink" title="题二十 先留在这里"></a>题二十 先留在这里</h1><h1 id="题二十一-将数组中的奇数全移到偶数前"><a href="#题二十一-将数组中的奇数全移到偶数前" class="headerlink" title="题二十一 将数组中的奇数全移到偶数前"></a>题二十一 <a href="https://github.com/JiaoMaWHU/jzoffer/blob/master/21.cpp" target="_blank" rel="noopener">将数组中的奇数全移到偶数前</a></h1><p>书中这题的要求和题目一样，这样的话，直接从左和右边向中间靠近判断即可。但是牛客网的oj上还要求偶数之间，奇数之间的相对顺序保持一致，这样的话，用冒泡排序，每次把最左边的数字确定即可。</p><h1 id="题二十二-链表中倒数第k个节点"><a href="#题二十二-链表中倒数第k个节点" class="headerlink" title="题二十二 链表中倒数第k个节点"></a>题二十二 <a href="https://github.com/JiaoMaWHU/jzoffer/blob/master/22.cpp" target="_blank" rel="noopener">链表中倒数第k个节点</a></h1><p>很显然，官是不会接受遍历两次这种做法的。那么如何一次遍历就完成这个操作呢？我们可以在第一个指针走出k-1步后，使第二个指针指向开头，并与第一个指针同步向后移动。这样第二个指针最后指向的就是目标节点。我们还要考虑几个边界情况：1.头指针为空；2.k超出链表范围；3.k为0；</p><h1 id="题二十三-链表中环的入口节点"><a href="#题二十三-链表中环的入口节点" class="headerlink" title="题二十三 链表中环的入口节点"></a>题二十三 <a href="https://github.com/JiaoMaWHU/jzoffer/blob/master/23.cpp" target="_blank" rel="noopener">链表中环的入口节点</a></h1><p>首先，要判断有无环，当一个每次走两步的指针和一个每次走一步的指针相遇的时候，链表显然存在环。然后，我们来找入口节点：让一个指针先走环大小的步数，这样，两个指针相遇的点就是入口节点。那么，怎么找到环的大小呢？让判断环相遇的指针，一个留在原地，一个每次一步地继续走，这样重新相遇的时候，就可以知道步数。我们还要考虑边界情况：1.头指针为空；总之，这个方法很巧妙啊，自己想不知道要想到什么时候。</p><h1 id="题二十四-反转链表"><a href="#题二十四-反转链表" class="headerlink" title="题二十四 反转链表"></a>题二十四 <a href="https://github.com/JiaoMaWHU/jzoffer/blob/master/24.cpp" target="_blank" rel="noopener">反转链表</a></h1><p>很显然，用两个指针和一个辅助指针就能在一次遍历后完成反转。我们要考虑这样几个边界情况：1.头结点为空；2.只有一个节点。</p><h1 id="题二十五-合并两个排序的链表"><a href="#题二十五-合并两个排序的链表" class="headerlink" title="题二十五 合并两个排序的链表"></a>题二十五 <a href="https://github.com/JiaoMaWHU/jzoffer/blob/master/25.cpp" target="_blank" rel="noopener">合并两个排序的链表</a></h1><p>以单调不减的顺序合并两个单调递增的链表。很显然，用两个指针就可以完成操作。我们需要考虑的边界情况：1.一个链表为空；2.两个全为空；我使用了循环来实现，书中用的是递归。看了下，还是递归简单一点。P</p><h1 id="题二十六-树的子结构"><a href="#题二十六-树的子结构" class="headerlink" title="题二十六 树的子结构"></a>题二十六 <a href="https://github.com/JiaoMaWHU/jzoffer/blob/master/26.cpp" target="_blank" rel="noopener">树的子结构</a></h1><h1 id="题三十二-从上往下打印二叉树"><a href="#题三十二-从上往下打印二叉树" class="headerlink" title="题三十二 从上往下打印二叉树"></a>题三十二 从上往下打印二叉树</h1><h2 id="题目二-1"><a href="#题目二-1" class="headerlink" title="题目二"></a><a href="https://github.com/JiaoMaWHU/jzoffer/blob/master/32-2.cpp" target="_blank" rel="noopener">题目二</a></h2><p>我们显然可以使用队列来实现，推广来说，不仅是层次遍历二叉树，只要是BFS，我们都可以用队列来实现。</p><p>要求从上向下打印二叉树，每层有个换行。咋实现呢？书中给出方法是用两个变量来记录。一个代表当前层，如果当前层的剩余数目还没有打印完，那么增加的分支就都是下一层的，依次类推。</p><h2 id="题目三"><a href="#题目三" class="headerlink" title="题目三"></a><a href="https://github.com/JiaoMaWHU/jzoffer/blob/master/32-3.cpp" target="_blank" rel="noopener">题目三</a></h2><p>要求用之字形的顺序打印二叉树。我想的方法是，判断当前是奇数还是偶数行，如果是奇数，那么正常输出，如果是偶数，把输出存储在栈中，等当前行结束后，再统一输出。通过了测试。书上给的则是另外一种方法，</p><h1 id="题三十五-复杂链表的复制"><a href="#题三十五-复杂链表的复制" class="headerlink" title="题三十五 复杂链表的复制"></a>题三十五 <a href="https://github.com/JiaoMaWHU/jzoffer/blob/master/35.cpp" target="_blank" rel="noopener">复杂链表的复制</a></h1><p>好吧，你要让我想一个O(n)时间内，不用牺牲空间可以复制复杂指针的算法，我还真想不出来。老老实实看书吧，把新的节点都连到老节点的下一个，链接完两种指针后，再拆开就可以了。</p><h1 id="题四十三-整数中1出现的次数"><a href="#题四十三-整数中1出现的次数" class="headerlink" title="题四十三 整数中1出现的次数"></a>题四十三 <a href="https://www.nowcoder.com/profile/218843849/codeBookDetail?submissionId=60674434" target="_blank" rel="noopener">整数中1出现的次数</a></h1><p>很直接的想法：模十，如果结果为1，代表个位为1。而后，除以十即可循环判断各个位了。</p><h1 id="题五十二-两个链表的第一个公共子节点"><a href="#题五十二-两个链表的第一个公共子节点" class="headerlink" title="题五十二 两个链表的第一个公共子节点"></a>题五十二 <a href="https://github.com/JiaoMaWHU/jzoffer/blob/master/53.cpp" target="_blank" rel="noopener">两个链表的第一个公共子节点</a></h1><p>有了<strong>倒数第k个节点</strong>这个思路过后，这个题就最优解就可以想到了。我们先开始一边遍历并计数，如果最后两个指针相同，那么证明有公共点。那么根据计数的差别，我们先让两个指针步数同步（离终节点距离相同），这样就能判断第一个公共点了。</p><p>但是还有种幺蛾子情况我们需要考虑，如果链表是有环的呢？我们必须要先问清楚官，如果有环，我们就要使两个指针前进的步数不同，这样如果相遇的话，就是相交的。我们把这个点存起来，可以根据判断得到步数相差，从而得到第一个公共子节点（环的入口节点）。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;剑指offer刷题的记录与总结
    
    </summary>
    
    
      <category term="Algorithms" scheme="https://jiaomawhu.github.io/tags/Algorithms/"/>
    
  </entry>
  
  <entry>
    <title>支持向量机SVM总结</title>
    <link href="https://jiaomawhu.github.io/2019/02/11/ml/svm/"/>
    <id>https://jiaomawhu.github.io/2019/02/11/ml/svm/</id>
    <published>2019-02-12T04:04:19.000Z</published>
    <updated>2021-01-18T02:46:28.073Z</updated>
    
    <content type="html"><![CDATA[<p>今天来总结下硬间隔支持向量机 (Support Vector Machine)，由于支持向量机中的对偶问题包含大量的推导，完全用公式码出来太浪费时间，所以我就以总结写提纲的方式来写本文。<a id="more"></a></p><p>现在有一些训练样本，我们想通过在样本空间寻找一些超平面来把他们划分开来。此外，我们还要求该超平面对样本局部扰动的容忍性较好，也就说我们不仅要考虑已有样本，对那些可预见的样本分布，我们也要尽量把他们分离开。<br><img src="/images/svm_location.png" alt=""><br>也就是说，我们要尽量选取像图中红色那样的划分区间。</p><p>我们一般用$\omega^Tx+b$来描述这一超平面，空间中任意点到超平面$(\omega,b)$的距离可以写成</p><script type="math/tex; mode=display">r=\frac{|\omega^T\textbf{x}+b|}{||\omega||}</script><p>并可以用向量知识证明。对于一组超平面，如果其能使对于任意$(\textbf{x}_i,y_i)\in D$，有</p><script type="math/tex; mode=display">\left \{\begin{aligned}\omega^T\textbf{x}_i+b \geq +1, y_i = +1\\\omega^T\textbf{x}_i+b \leq -1, y_i = -1\end{aligned} \right.</script><p>我们就称它就能够将训练样本正确分类。实际上，{+1,-1}这个取值并不重要，因为一旦能满足上式，其他的值也都能满足。能使上式等号成立的点被我们成为支持向量。然后，我们把优化问题归纳成：</p><script type="math/tex; mode=display">\max_{\omega,b}\frac{2}{||\omega||}\\\mbox{s.t.}\ \ y_i(\omega^T\textbf{x}+b)\geq 1, i=1,2,\cdots,m</script><p>其中$\frac{2}{||\omega||}$指的是两个异类支持向量到划分平面的距离之和。为了简化计算，我们又可以把上式重写成：</p><script type="math/tex; mode=display">\min_{\omega,b}\frac{||\omega||^2}{2}\\\mbox{s.t.}\ \ y_i(\omega^T\textbf{x}+b)\geq 1, i=1,2,\cdots,m</script><p>经过拉格朗日的对偶问题转换，上述问题可转化为：</p><script type="math/tex; mode=display">\max_{\alpha}\sum^m_{i=1}\alpha_i-\frac{1}{2}\sum^m_{i=1}\sum^m_{j=1}\alpha_i\alpha_jy_iy_j{\textbf{x}_i}^T\textbf{x}_j\\\mbox{s.t.}\ \sum^m_{i=1}\alpha_iy_i=0\\\alpha_i\geq0, i=1,2,\cdots,m.</script><p>省略一堆证明，原理是通过拉格朗日极大极小规约，来推导出上述问题的解相当于其对偶问题的解。但在这里要补充：在对偶问题的转化中，需要满足KKT条件。这种限定，使得模型训练仅受那些最大分割边界上的那些样本的影响，这也就是为什么称他们为支持向量。</p><p>假如我们能求出$\mathbf{\alpha}$,我们就可以得到划分超平面的公式:</p><script type="math/tex; mode=display">f(x)=\omega^T\textbf{x}+b\\=\sum^m_{i=1}\alpha_iy_i{\textbf{x}_i}^T\textbf{x}_i+b</script><p>为啥嘞？因为在省去的对偶问题推导中，有式$\omega=\sum^m_{i=1}\alpha_iy_i\textbf{x}_i$。OK，那咋求$\alpha$呢？周老师云，二次规划算法易解之，（好吧，不懂）。但他又说用SMO求更高效。SMO算法指的是固定一对$\alpha_i,\alpha_j$然后求极值，然后一直迭代到底。具体实现中，SMO先选取一个违背KKT条件最大的值，再选取一个下一个变量，它的样本与上值对应的样本间隔最大。</p><p>实际上，划分远远没有这么简单，因为有时候在样本维度，根本不存在这样一个划分空间。很直观的一个想法就是把数据升维。假设，我们找到了合适的维度，这个维度存在对样本$\textbf{x}\Rightarrow\phi(\textbf{x})$的划分空间，可惜的是，高维向量$\phi(x)$的转置和乘积一般都是很很困难的。为了解决这个问题，引入了核函数。我们令核函数为$\kappa(\textbf{x}_i,\textbf{x}_j)={\phi(\textbf{x}_i)}^T\phi(\textbf{x}_j)$。只要一个对称函数所对应的核矩阵半正定，它就能作为核函数使用。我们一般常使用的核函数如下图：<br><img src="/images/svm_location.png" alt=""><br>当我们选择一个核函数来作为两样本的高纬度内积后，就有式：</p><script type="math/tex; mode=display">f(x)=\omega^T\textbf{x}+b\\=\sum^m_{i=1}\alpha_iy_i\kappa(\textbf{x}_i,\textbf{x}_j)+b</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天来总结下硬间隔支持向量机 (Support Vector Machine)，由于支持向量机中的对偶问题包含大量的推导，完全用公式码出来太浪费时间，所以我就以总结写提纲的方式来写本文。
    
    </summary>
    
    
      <category term="Machine Learning" scheme="https://jiaomawhu.github.io/tags/Machine-Learning/"/>
    
  </entry>
  
  <entry>
    <title>集成学习总结：GBDT, xgboost方法</title>
    <link href="https://jiaomawhu.github.io/2019/01/12/ml/BoostingNewMethod/"/>
    <id>https://jiaomawhu.github.io/2019/01/12/ml/BoostingNewMethod/</id>
    <published>2019-01-12T17:39:56.000Z</published>
    <updated>2021-01-18T02:46:17.700Z</updated>
    
    <content type="html"><![CDATA[<p>OK, 我们在前文中已经讨论过了Boosting的一个算法：AdaBoost，在本文中，我们来看看Boosting族中其他两个重要算法：GBDT和xgboost。<a id="more"></a></p><h2 id="GBDT"><a href="#GBDT" class="headerlink" title="GBDT"></a>GBDT</h2><p>GBDT (Gradiennt Boosting Decision Tree) 梯度提升树（以决策树为基函数的提升方法称为提升树）采用的是和AdaBoost一样的线性模型，并通过迭代不断更新权值分布。然而其限定只能使用CART回归树模型，而且迭代思路和AdaBoost也不同。接下来，我们从损失函数选取的角度来讨论下，GBDT和AdaBoost的不同。</p><p>在Boosting的迭代中，我们在第$m-1$轮后得到了学习器$[f_1 \cdots f_{m-1}]$，我们希望下一轮的学习器$f_m$能够纠正存在的错误，即</p><script type="math/tex; mode=display">f_m(x)=\mathop{\arg\min}_{f}L(f_{m-1}+f|D)</script><p>其中$L$是损失函数，$D$是训练集。AdaBoost选择了指数损失函数，然后用泰勒公式展开后发现：让$D_m$服从某一分布，即可使得损失函数达到最小 （具体证明可参照西瓜书），这也是为啥AdaBoost要去改变权值分布。而GBDT则不一样，其希望$f_m$能够使损失函数在第$m$轮，走向$m-1$轮中<strong>损失函数下降最快的方向</strong>。</p><p>具体看下GBDT的流程。假设有个回归问题，我们使用决策树作为基学习器。决策树的预测为</p><script type="math/tex; mode=display">T(x;\theta)=\sum^J_{j=1}\gamma_jI(x\in R_j)</script><p>其中$R_j$是区域，$\gamma$是返回值，$I$条件成立情况下为1，否则为0，其中的参数$J$可以大概看做树的深度的一个表示，这是一个待调的参数。那么GBDT解决这个问题的具体流程如下图:<br><img src="/images/gbdt_per.jpg" alt=""></p><p>这里等待复习完决策树再进行总结。</p><p>Boosting算法也可以用使用的损失函数来归类，如下图：<br><img src="/images/gbdt_loss.jpg" alt="">可以看到AdaBoost选取的是指数损失函数，而GBDT选取的是绝对值损失函数。</p><h2 id="xgboost"><a href="#xgboost" class="headerlink" title="xgboost"></a>xgboost</h2><p>xgboost 的全称是eXtreme Gradient Boosting，由华盛顿大学的陈天奇博士提出，在Kaggle的希格斯子信号识别竞赛中使用，因其出众的效率与较高的预测准确度而引起了广泛的关注。</p><p>与Adboost的区别：GBDT算法只利用了一阶的导数信息，xgboost对损失函数做了二阶的泰勒展开，并在目标函数之外加入了正则项对整体求最优解，用以权衡目标函数的下降和模型的复杂程度，避免过拟合。所以不考虑细节方面，两者最大的不同就是目标函数的定义。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;OK, 我们在前文中已经讨论过了Boosting的一个算法：AdaBoost，在本文中，我们来看看Boosting族中其他两个重要算法：GBDT和xgboost。
    
    </summary>
    
    
      <category term="Machine Learning" scheme="https://jiaomawhu.github.io/tags/Machine-Learning/"/>
    
  </entry>
  
  <entry>
    <title>集成学习总结：Bagging</title>
    <link href="https://jiaomawhu.github.io/2019/01/08/ml/bagging/"/>
    <id>https://jiaomawhu.github.io/2019/01/08/ml/bagging/</id>
    <published>2019-01-08T17:39:56.000Z</published>
    <updated>2021-01-18T02:46:06.736Z</updated>
    
    <content type="html"><![CDATA[<p>在这篇文章中总结bagging的概念与意义，并以随机森林为例，进行详细讨论。<br><a id="more"></a></p><h2 id="Bagging"><a href="#Bagging" class="headerlink" title="Bagging"></a>Bagging</h2><p>在上篇中我们提到，“好而不同”是集成学习的关键问题。Boosting通过序列化获取更好效果的学习器，来达到更好的集成，却损失了“不同”这一性质。Bagging是集成学习中的另一类算法，它的目标就是既要“好”又要“不同”。为了实现“不同”这一目标，Bagging把训练样本划分为子集，这样不同子集训练出的学习器的独立性就会提高。而Bagging又使子集都存在一定重叠，因为如果采样出的子集都完全不同，说明每个学习器都只用到了一小部分数据，甚至不足以有效学习。这种重叠的子集划分就完成了让每个学习器训练更充分，变得更“好”的这个目标。</p><p>具体来说，对一个有$m$个样本的数据集，Bagging首先进行子集划分，对每个子集，从数据集中做$m$次有放回的随机选取，最后生成$T$个子集。由于$\lim_{m \to \infty} (1-1/m)^m \to 1/e \approx 0.368$，所以会有$36.8\%$的数据我们是没有取到的。随后，Bagging分别使用这$T$个数据集训练出$T$个学习器。在预测时，如果是分类任务，则使用简单投票法，如果是预测任务，则使用简单平均法。下图是具体流程<br><img src="/images/bagging.png" alt=""><br>最后一步的输出表示的是简单投票法，投票得数最多的$y$成为最后的结果。假设单个基学习器的计算复杂度是$O(m)$，那么最后算法的复杂度就趋于$O(m)$，因为最后的投票计算复杂度很小。</p><h2 id="随机森林"><a href="#随机森林" class="headerlink" title="随机森林"></a>随机森林</h2><p>随机森林 (Random Forest) 是Bagging的一种变体算法，它在以决策树构建Bagging的基础上，抛弃了原本的最优属性划分原则，规定从已有的$d$个属性点中随机取出$k$个属性点构成子集，并从子集中得到最优属性点。推荐值为$k=log_2d$。</p><p>随机森林简单，易实现，计算开销小，且在很多现实任务中表现很好。因为其不仅具有Bagging对数据集扰动的性质，还具有对属性点划分的第二重扰动，这使得学习器之间独立性较好。随机森林与Bagging收敛性相似，起始性能较差，但随着学习器数目的增加，却能达到更低的误差。而且不难理解，由于只选出了$k$个属性进行选取，其训练性能要优于$Bagging$。</p><h2 id="参考资源"><a href="#参考资源" class="headerlink" title="参考资源"></a>参考资源</h2><p>[1]机器学习西瓜书，周志华</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在这篇文章中总结bagging的概念与意义，并以随机森林为例，进行详细讨论。&lt;br&gt;
    
    </summary>
    
    
      <category term="Machine Learning" scheme="https://jiaomawhu.github.io/tags/Machine-Learning/"/>
    
  </entry>
  
  <entry>
    <title>集成学习总结：Boosting</title>
    <link href="https://jiaomawhu.github.io/2019/01/07/ml/boosting/"/>
    <id>https://jiaomawhu.github.io/2019/01/07/ml/boosting/</id>
    <published>2019-01-07T23:49:09.000Z</published>
    <updated>2021-01-18T02:46:12.464Z</updated>
    
    <content type="html"><![CDATA[<p>最近了解了集成学习中的Boosting，以及衍生算法AdaBoost。在此对他们进行总结。<a id="more"></a></p><h2 id="集成学习"><a href="#集成学习" class="headerlink" title="集成学习"></a>集成学习</h2><p>首先，什么是<strong>集成学习（ensemble learning）</strong>？通过构建并结合多个学习器来完成学习任务的方法，通常被称为集成学习。这样的学习器，可以是同种学习器（同质），其亦可被称为基学习器。学习器也可以是不同的（异质），例如C4.5决策树，BP神经网络。此时基学习器不再存在，我们称每个学习器为个体学习器。</p><p>集成学习有个特点：结合多个学习器的效果，往往会比单个弱学习器的效果好的多。然而，从生活经验出发，当我们把一些效果很差的东西（例如，运行速度很慢的代码）结合在一起的时候，效果往往会更差。那集成学习是如何达到这种更好的效果的呢？下面参照西瓜书给出证明。</p><p>现在有一个二分类问题 $y\in\{+1,-1\}$，真实函数为 $f$。有$T$个分类器，且基分类器的误差为 $\epsilon$。我们使用投票法来决定最后的输出，也就是说如果有超过半数基分类器输出为-1，那最后结果$H(x)$就为-1。那么，我们就可以得到学习的误差为</p><script type="math/tex; mode=display">P(H(x)\neq f(x))=\sum^{\lfloor T/2\rfloor}_{k=0}C_T^k(1-\epsilon)^k\epsilon^{T-k}</script><p>那么，假设分类器的预测相互独立，根据Hoeffding不等式，我们有</p><script type="math/tex; mode=display">P(H(x)\neq f(x))=P(G(x) \leq{\lfloor T/2\rfloor}) \leq exp(-2(1/2-\epsilon)^2 T)</script><p>其中，$G(x)$是指预测结果为真的分类器的个数。</p><blockquote><p>Hoeffding不等式：假某抛硬币朝上的概率为$p$，且相互独立，若连续抛 $n$次且最多朝上$k$次，即$P(G(n)\leq k)$。存在 $c&gt;0, k=(p-c)n$，使得$P(G(n)\leq (p-c)n) \leq exp(-2c^2 n)$</p></blockquote><p>由此我们可见，随着$T$增大，误差会呈指数级下降。这也就解释了为什么学习器越多，整体的学习效果会越好。</p><p>然而，学习器的预测实际上不满足Hoeffding不等式相互独立的条件。为了尽量满足相互独立的条件，我们需要使学习器尽可能多样。但这种多样性则往往会带来准确性的下降。于是，如何产生<strong>“好而不同”</strong>的学习器，就成为了集成学习的核心问题。 </p><h2 id="Boosting"><a href="#Boosting" class="headerlink" title="Boosting"></a>Boosting</h2><p>Boosting就是集成学习的一种，它采用强依赖的学习器，而且通过序列化生成结果。也就是说，<em>Boosting并不具有丰富的多样性，它通过提高学习器的预测准确性，来提高集成学习的效果。</em></p><p>具体来说，Boosting增大对预测错误的数据的关注，赋予他们更大的权重，然后通过更新的数据，序列化生成新学习器，在达到设定值后，对所有学习器做加权结合。</p><p>AdaBoost(adaptive boosting)是Boosting族中具有代表性的算法，接下来我们具体研究下。</p><h3 id="AdaBoost"><a href="#AdaBoost" class="headerlink" title="AdaBoost"></a>AdaBoost</h3><p>简单来说，AdaBoost做了两件事情: 一是像我们上面说的，在增大对预测错误的数据的关注；二是增大预测效果好的学习器的权重。具体算法流程如下下图所示：<br><img src="/images/adaboost.png" alt="">其中$D_t(x)$是在第$t$轮数据集的权值分布，$h_t$就是在第$t$轮中最优学习器预测的结果。</p><p>在第6步中，我们首先根据误差得到一个正参数$\alpha_t$。在第7步中，数据集中预测正确的数据都要和$-\alpha_t$的指数相乘，而预测正确的数据则和$\alpha_t$的指数相乘，这样预测错误的数据就得到了更大的权值，最后每个权值除以权值之和$Z_t$，就得到了下一轮的权值分布。在迭代结束，或者误差率超过阈值的时候，开始最后的输出。我们观察到，$h_t$的预测误差越低，$\alpha_t$越大，它在最后输出中占的比重就越大，这就实现了上面所说的增大预测效果好的学习器的权重。我们把这种得到$H(x)$的方法叫做线性加法模型。</p><p>OK，这样设置是很有道理，但设计者是咋想出来这种方法的呢？实际上，$\alpha_t$和权值分布$D_t$的更新都可以通过推导得到，由于过程过于繁琐，请参考西瓜书具体章节。</p><h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><p>好啦，下面我们来看个具体的例子。<br>假设我们有一个这样的数据集</p><div class="table-container"><table><thead><tr><th>x</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th></tr></thead><tbody><tr><td>y</td><td>1</td><td>1</td><td>-1</td><td>-1</td><td>1</td><td>-1</td></tr></tbody></table></div><p>我们使用二分类决策树作为基分类器，验算第一轮过程：<br>1.首先初始化$D_1=(0.167, 0.167, 0.167, 0.167, 0.167, 0.167)$<br>2.获得最优$h_1$与误差<br>若按0.5切分数据，得弱分类器x &lt; 0.5,则 y = 1; x &gt; 0.5, 则 y = -1。此时误差为2 * 0.167 = 0.334</p><p>若按1.5切分数据，得弱分类器x &lt; 1.5,则 y = 1; x &gt; 1.5, 则 y = -1。此时误差为<strong>1 * 0.167 = 0.167</strong></p><p>若按2.5切分数据，得弱分类器x &lt; 2.5,则 y = 1; x &gt; 2.5, 则 y = -1。此时误差为2 * 0.167 = 0.334</p><p>若按3.5切分数据，得弱分类器x &lt; 3.5,则 y = 1; x &gt; 3.5, 则 y = -1。此时误差为3 * 0.167 = 0.501</p><p>若按4.5切分数据，得弱分类器x &lt; 4.5,则 y = 1; x &gt; 4.5, 则 y = -1。此时误差为2 * 0.167 = 0.334</p><p>则最优弱分类器为x &lt; 1.5,则 y = 1; x &gt; 1.5, 则 y = -1。</p><p>3.计算得$\alpha_1=0.5 * ln((1 – 0.167) / 0.167) = 0.8047$<br>4.随后根据$\alpha_1$和预测结果，即可进行权重的更新。</p><h3 id="Coding"><a href="#Coding" class="headerlink" title="Coding"></a>Coding</h3><p>那代码改怎么写呢？<br>我们首先把函数设计成这样:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    x = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">    y = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">-1</span>]</span><br><span class="line">    fx = trainAdaBoost(x, y, T) <span class="comment">#训练得到的学习器</span></span><br><span class="line">    print(fx)</span><br></pre></td></tr></table></figure></p><p>然后我们按照算法流程顺序，首先计算可能的划分点:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">separatePoint</span><span class="params">(x)</span>:</span></span><br><span class="line">sp = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(x)<span class="number">-1</span>):</span><br><span class="line">sp.append((x[i]+x[i+<span class="number">1</span>])/<span class="number">2</span>)</span><br><span class="line"><span class="keyword">return</span> sp</span><br></pre></td></tr></table></figure></p><p>然后，我们找出最优的划分点:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findBestSp</span><span class="params">(sp,x,y,D_t)</span>:</span></span><br><span class="line">error=<span class="number">1</span>;</span><br><span class="line">bestsp=<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(sp):</span><br><span class="line">error_i=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(x):</span><br><span class="line"><span class="keyword">if</span> x[j] &lt; sp[i] <span class="keyword">and</span> y[j] != <span class="number">1</span>: error_i += D_t[j]</span><br><span class="line"><span class="keyword">if</span> x[j] &gt; sp[i] <span class="keyword">and</span> y[j] != <span class="number">-1</span>: error_i += D_t[j]</span><br><span class="line"><span class="keyword">if</span> error_i &lt; error: </span><br><span class="line">error = error_i</span><br><span class="line">bestsp = i</span><br><span class="line"><span class="keyword">return</span> bestsp, error</span><br></pre></td></tr></table></figure></p><p>开始计算alpha，并更新权值:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">alphaAndWeight</span><span class="params">(x,y,D_t)</span>:</span></span><br><span class="line">sp = separatePoint(x)</span><br><span class="line">bestsp, error = findBestSp(sp,x,y,D_t)</span><br><span class="line"><span class="keyword">if</span> error &gt; <span class="number">0.5</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span></span><br><span class="line">alpha = (<span class="number">1</span>/<span class="number">2</span>)*log((<span class="number">1</span>-error)/error)</span><br><span class="line">D_tn = D_t</span><br><span class="line">Z=<span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(x):</span><br><span class="line"><span class="keyword">if</span> x[i] &lt; sp[bestsp] <span class="keyword">and</span> y[i]!=<span class="number">1</span>: D_tn[i]=D_tn[i]*exp(alpha)</span><br><span class="line"><span class="keyword">elif</span> x[i] &gt; sp[bestsp] <span class="keyword">and</span> y[i]!=<span class="number">-1</span>: D_tn[i]=D_tn[i]*exp(alpha)</span><br><span class="line"><span class="keyword">else</span>: D_tn[i]=D_tn[i]*exp(-alpha)</span><br><span class="line">Z+=D_tn[i]</span><br><span class="line">D_tn/=Z</span><br><span class="line"><span class="keyword">return</span> sp, alpha, D_tn</span><br></pre></td></tr></table></figure></p><p>训练函数:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">trainAdaBoost</span><span class="params">(x, y, T)</span>:</span></span><br><span class="line">D_1 = [<span class="number">1</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(x)]</span><br><span class="line">D_1 /= len(x)</span><br><span class="line">Alpha = []</span><br><span class="line">D = [D_1]</span><br><span class="line">SP = []</span><br><span class="line">D_tn = D_1</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">1</span>:T):</span><br><span class="line">sp, alpha, D_tn = alphaAndWeight(x,y,D_tn)</span><br><span class="line"><span class="keyword">if</span> sp==<span class="number">-1</span> <span class="keyword">and</span> alpha==<span class="number">-1</span> <span class="keyword">and</span> D_tn==<span class="number">-1</span>: <span class="keyword">break</span></span><br><span class="line">SP.append(sp)</span><br><span class="line">D.append(D_tn)</span><br><span class="line">Alpha.append(alpha)</span><br><span class="line"><span class="comment">#接下来计算结果</span></span><br><span class="line">test=[]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(x):</span><br><span class="line">test_y=<span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(SP):</span><br><span class="line"><span class="keyword">if</span> x[i] &lt; SP[j]: test_y += D_tn[j][i]</span><br><span class="line"><span class="keyword">else</span>: test_y -= D_tn[j][i]</span><br><span class="line"><span class="keyword">if</span> test_y&gt;<span class="number">0</span>: test.append(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">else</span>: test.append(<span class="number">0</span>) </span><br><span class="line"><span class="keyword">return</span> test</span><br></pre></td></tr></table></figure></p><p>最后运行，就可以把最后的test输出打印出来啦</p><h2 id="参考资源"><a href="#参考资源" class="headerlink" title="参考资源"></a>参考资源</h2><p>[1]机器学习西瓜书，周志华<br><a href="https://zyzypeter.github.io/2017/08/08/machine-learning-ch12-boosting/" target="_blank" rel="noopener">[2]机器学习 第十二章 集成学习（1） 提升学习</a><br><a href="https://www.ibm.com/developerworks/cn/analytics/library/machine-learning-hands-on6-adaboost/index.html" target="_blank" rel="noopener">[3]手把手教你实现一个 AdaBoost</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近了解了集成学习中的Boosting，以及衍生算法AdaBoost。在此对他们进行总结。
    
    </summary>
    
    
      <category term="Machine Learning" scheme="https://jiaomawhu.github.io/tags/Machine-Learning/"/>
    
  </entry>
  
  <entry>
    <title>0/1 Knapsack Problem</title>
    <link href="https://jiaomawhu.github.io/2018/12/18/cscore/01knapsack-problem/"/>
    <id>https://jiaomawhu.github.io/2018/12/18/cscore/01knapsack-problem/</id>
    <published>2018-12-19T01:51:22.000Z</published>
    <updated>2021-01-18T02:44:46.541Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Definition"><a href="#Definition" class="headerlink" title="Definition"></a>Definition</h3><p>Given N items and a knapsack with C weight. For each item i that has the value s[i] and the weight v[i], decide whether to include it (1) or not (0) to attain the largest total value.<br><a id="more"></a></p><h3 id="Basic-Solution"><a href="#Basic-Solution" class="headerlink" title="Basic Solution"></a>Basic Solution</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>$A_{a,b}$</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Definition&quot;&gt;&lt;a href=&quot;#Definition&quot; class=&quot;headerlink&quot; title=&quot;Definition&quot;&gt;&lt;/a&gt;Definition&lt;/h3&gt;&lt;p&gt;Given N items and a knapsack with C weight. For each item i that has the value s[i] and the weight v[i], decide whether to include it (1) or not (0) to attain the largest total value.&lt;br&gt;
    
    </summary>
    
    
      <category term="Algorithms" scheme="https://jiaomawhu.github.io/tags/Algorithms/"/>
    
  </entry>
  
  <entry>
    <title>写文书的注意事项</title>
    <link href="https://jiaomawhu.github.io/2018/11/23/tips-for-ps-sop/"/>
    <id>https://jiaomawhu.github.io/2018/11/23/tips-for-ps-sop/</id>
    <published>2018-11-23T18:13:33.000Z</published>
    <updated>2021-01-18T02:47:03.463Z</updated>
    
    <content type="html"><![CDATA[<p>写文书的时候，深感英文写作水平的匮乏。好在文书不全看写作水平，因此多方寻找经验贴阅读。网络上有如此多的经验介绍贴，无非就是两种，一种是详细向导：哪一段写什么怎么写，另一种则是Tips：侧重原则方法论。我在阅读一亩三分地用户<code>YiranCdr</code>收集的<a href="https://www.1point3acres.com/bbs/forum.php?mod=viewthread&amp;tid=434161&amp;extra=page%3D1" target="_blank" rel="noopener">汇总贴</a>时，有不少收获，特此把其中的有用的Tips整理出来，以供写文书查阅。<br><a id="more"></a></p><h4 id="PS-SOP"><a href="#PS-SOP" class="headerlink" title="PS/SOP"></a>PS/SOP</h4><ul><li>从自己的经历出发，写清楚自己干了什么，对什么感兴趣，为什么要申请；</li><li>开篇就点出你的兴趣方向；</li><li>检查自己的文书中的每一句话是否回答了以下的问题，以防废话和偏离主题；<ol><li>你的研究兴趣是什么 </li><li>你是如何产生兴趣的，并且为这个兴趣付出了什么 </li><li>你在你的兴趣方向取得了什么样成绩 </li><li>为什么要继续你的研究，什么事情触发了你的念头 </li><li>为什么选择某某university </li><li>因为你有什么特别之处，某某大学因此要录取你 以上三点from</li></ol></li><li>可以从一次面试经历的方式来审查修改自己的文书；<code>以上几点来自用户andeyhongyeIVY</code></li></ul><blockquote><p>委员会：Prof.xx, Here is an applicant who is interested in your research field.<br>老美：Oh? Let me see. why are you interested in xxx？<br>ME：在xxx年，我作了xxx，这个项目是xxx，里面有什么东西触发了我。balabala。。<br>老美：Very good。what about next?<br>ME:之后，我开始学习xxxx，做了xx项目，在其中我遇到了xx问题，我提出了xxx想法。。。。<br>老美：You are good。But as our program is very competitive，how can we distinguish you from other applicants？. visit 1point3acres for more.<br>ME：我拿了xx奖啊，发了xx paper啊，做的项目很牛鼻啊。。。。<br>老美：A lot of applicants have the same experience as you。Well。。。（准备据人了）<br>ME：<u>我对专业有独特的见解，我有很多不一样的想法，项目虽然类似，但是我有不同的收获！！</u>（为啥早不说）<br>老美：oh？Interesting。Shot!<br>ME: <u>balabala</u>（划重点，这个东西就是你PS的精华了）<br>老美：Excellent！！I think you are remarkable。How did you become interested in our university？<br>ME:balabala。. visit 1point3acres for more.<br>老美：Good。Why me （why my research group）？<br>ME:balabala。（因为你的项目和我的很接近啊，对我很有启发啊。。。。）<br>老美：Good。 I think you are one we are looking for。If we give you an offer，will you accept it？<br>ME：Definitely！</p></blockquote><ul><li><p>关于PS，SOP，SOD的区别 <code>From liuuki</code></p><ol><li>personal statement→为什么来读（兴趣），为什么选项目，为目标做了什么（经历），<u>可以给项目带来什么</u>（对同学贡献，对教授贡献）</li><li>sop→要求一篇sop=ps（个人经历，课外活动，志愿者，人生规划等）—学术生活写一篇，要求两篇—sop侧重学术（学术兴趣，职业规划，学术经历）—分开写，适当增减。</li><li>statement of diversity→学生背景多样性（学术领域，兴趣，家庭，社会族群），我的规划能带来什么多样性（什么多样性，怎么带来）eg.中医世家申请生物医药，政府官员家庭（了解中国）申请社会学历史学等，少数民族（语言融合）申请语言类，家庭背景（和本国比）差怎么对自己性格塑造产生影响</li><li><u>无需写出论文名和会议名（因为CV中已经写出来了，这点需要具体研究）</u></li></ol></li><li><p><code>huzhongkai</code>提到了重复信息的问题，他认为简历成绩单上能表现出来的东西为什么要重新说一次呢？有道理，但是我们在文书中必须提出能够支撑自己兴趣点的证据，这些证据又必然会在CV中被提到。看似是一个悖论，但我想<code>huzhongkai</code>想要突出的点是，<u>重点是这些经历是怎么影响到你的，从而使你out of page</u>，而不是像流水账一样陈述。</p></li><li><p><code>churchillyh:</code> <u>People who also get along well with others (work well and play well).</u> 这重要吗？需要研究下。XD</p></li><li><p><code>artlessu:</code> Don’t tell the story of your life in your statement; Purge most instances of passive voicing.</p></li><li><p>如果官方有问题要求的话，文书必须回答相应问题</p></li></ul><h4 id="Resume"><a href="#Resume" class="headerlink" title="Resume"></a>Resume</h4><ul><li><p>简历应该分为五大部分，第一部分是学校专业和相关课程，第二部分是实习经历，第三部分是课外实践经历，第四部分是获奖情况，第五部分是技能与兴趣。<code>From Yuzhiyo</code></p></li><li><p>各校指导的总结</p><ol><li>一页</li><li>使用具体且积极的动词来描述你的经历</li><li>句子简洁：Accomplished [x] as measured by [y] by doing [z]</li></ol></li></ul><h4 id="Recommendation-Letter"><a href="#Recommendation-Letter" class="headerlink" title="Recommendation Letter"></a>Recommendation Letter</h4><ul><li><p>推荐信的原则：<code>From Yuzhiyo</code></p><ol><li>推荐信谈的优点不能一致，注意搭配</li><li>避免用过于华丽的辞藻，用细节去体现你的优点</li><li>要用不同字号不同字体来写不同的推荐信，否则太假</li><li>推荐信不能写得太慢，字数不是衡量标准</li><li>每个学校对推荐信的要求有点不同，最好提前看看申请系统里对推荐信的要求（内容、字号、字体等)</li></ol></li><li><p><a href="https://cs.brown.edu/~sk/Memos/Grad-School-Recos/" target="_blank" rel="noopener">Shriram Krishnamurthi的RL写作指导</a>关键点摘录</p><ol><li>The One-Minute Rule：审查能否在一分钟之内抓住letter的重点</li><li>Be Concrete：使用细节来支撑对学生的推荐</li><li>老师应该提到自己的research track，从而增加可信度</li><li>可以提到往届的学生都去了哪里，然后和他们进行比较</li><li>Brown这样的学校，比较看重research，注重描写学生的research表现</li><li>Reporting on Personality：需要提及到学生人格是否容易相处</li></ol></li><li><p><a href="https://homes.cs.washington.edu/~mernst/advice/write-recommendation.html" target="_blank" rel="noopener">Michael Ernst: How to write a letter of recommendation</a>关键点摘录</p><ol><li>用详细的示例支撑你的观点</li><li>尝试将学生区分开来</li><li>和往届学生比较</li><li>合理，不要一直夸</li></ol></li></ul><blockquote><p>P.s. <a href="https://owl.purdue.edu/index.html" target="_blank" rel="noopener">Purdue Online Writing Lab</a> 是一个好地方，有很多guidelines</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;写文书的时候，深感英文写作水平的匮乏。好在文书不全看写作水平，因此多方寻找经验贴阅读。网络上有如此多的经验介绍贴，无非就是两种，一种是详细向导：哪一段写什么怎么写，另一种则是Tips：侧重原则方法论。我在阅读一亩三分地用户&lt;code&gt;YiranCdr&lt;/code&gt;收集的&lt;a href=&quot;https://www.1point3acres.com/bbs/forum.php?mod=viewthread&amp;amp;tid=434161&amp;amp;extra=page%3D1&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;汇总贴&lt;/a&gt;时，有不少收获，特此把其中的有用的Tips整理出来，以供写文书查阅。&lt;br&gt;
    
    </summary>
    
    
      <category term="Tutorial" scheme="https://jiaomawhu.github.io/tags/Tutorial/"/>
    
  </entry>
  
  <entry>
    <title>Hexo Markdown 语法总结</title>
    <link href="https://jiaomawhu.github.io/2018/11/16/testforpost/"/>
    <id>https://jiaomawhu.github.io/2018/11/16/testforpost/</id>
    <published>2018-11-17T04:00:10.000Z</published>
    <updated>2021-01-18T02:46:53.291Z</updated>
    
    <content type="html"><![CDATA[<p>总结下Hexo Markdown的语法，发现很多东西都只支持原生markdown。<br><a id="more"></a></p><h4 id="1-front-matter-格式"><a href="#1-front-matter-格式" class="headerlink" title="1.front-matter 格式:"></a>1.front-matter 格式:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">layout: &apos;[post]&apos;</span><br><span class="line">title: Hexo Markdown 语法总结</span><br><span class="line">date: 2018-11-16 20:00:10</span><br><span class="line">tags: Markdown</span><br><span class="line">categories: Tutorial</span><br><span class="line">toc: true</span><br><span class="line">mathjax: true</span><br></pre></td></tr></table></figure><h4 id="2-斜体-斜体-粗体：-粗体"><a href="#2-斜体-斜体-粗体：-粗体" class="headerlink" title="2.斜体: *斜体* 粗体：**粗体**"></a>2.<em>斜体</em>: <code>*斜体*</code> <strong>粗体</strong>：<code>**粗体**</code></h4><h4 id="3-分级标题："><a href="#3-分级标题：" class="headerlink" title="3.分级标题："></a>3.分级标题：</h4><h5 id="使用下划线"><a href="#使用下划线" class="headerlink" title="使用下划线"></a>使用下划线</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">一级</span><br><span class="line">=========</span><br><span class="line">二级</span><br><span class="line">---------</span><br><span class="line">### 三级</span><br></pre></td></tr></table></figure><h5 id="使用-标识"><a href="#使用-标识" class="headerlink" title="使用#标识"></a>使用#标识</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># H1</span><br><span class="line">## H2</span><br><span class="line">...</span><br><span class="line">###### H6</span><br></pre></td></tr></table></figure><h4 id="4-分割线：在单独一行使用"><a href="#4-分割线：在单独一行使用" class="headerlink" title="4.分割线：在单独一行使用 -------"></a>4.分割线：在单独一行使用 <code>-------</code></h4><h4 id="5-删除线-使用-删除线-下划线-lt-u-gt-balabala-lt-u-gt"><a href="#5-删除线-使用-删除线-下划线-lt-u-gt-balabala-lt-u-gt" class="headerlink" title="5.删除线: 使用~~删除线~~  下划线:&lt;u&gt;balabala&lt;/u&gt;"></a>5.<del>删除线</del>: 使用<code>~~删除线~~</code>  <u>下划线</u>:<code>&lt;u&gt;balabala&lt;/u&gt;</code></h4><h4 id="6-超链接："><a href="#6-超链接：" class="headerlink" title="6.超链接："></a>6.超链接：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[链接文字](地址 &quot;标题&quot;)</span><br><span class="line">![图片说明](地址 &quot;标题&quot;)</span><br></pre></td></tr></table></figure><h4 id="7-注释-注释文字"><a href="#7-注释-注释文字" class="headerlink" title="7.注释: \注释文字"></a>7.注释: <code>\注释文字</code></h4><h4 id="8-引用-gt-文字引用"><a href="#8-引用-gt-文字引用" class="headerlink" title="8.引用: &gt;文字引用"></a>8.引用: <code>&gt;文字引用</code></h4><h4 id="9-脚注-BlaBlaBla-anyword-anyword-Bla-means"><a href="#9-脚注-BlaBlaBla-anyword-anyword-Bla-means" class="headerlink" title="9.脚注: BlaBlaBla [^anyword], [anyword^]: Bla means ..."></a>9.脚注: <code>BlaBlaBla [^anyword], [anyword^]: Bla means ...</code></h4><h4 id="10-无序列表-：实心圆，-：空心圆，-：方形，有序列表：1-2"><a href="#10-无序列表-：实心圆，-：空心圆，-：方形，有序列表：1-2" class="headerlink" title="10.无序列表 +：实心圆，-：空心圆，*：方形，有序列表：1. 2."></a>10.无序列表 +：实心圆，-：空心圆，*：方形，有序列表：1. 2.</h4><h4 id="11-表格-绘制表格格式如下，-控制分列，-控制分行，-控制对齐方式。"><a href="#11-表格-绘制表格格式如下，-控制分列，-控制分行，-控制对齐方式。" class="headerlink" title="11.表格: 绘制表格格式如下，|控制分列，-控制分行，:控制对齐方式。"></a>11.表格: 绘制表格格式如下，<code>|</code>控制分列，<code>-</code>控制分行，<code>:</code>控制对齐方式。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">| Item     | Value     | Qty   |</span><br><span class="line">| :------- | --------: | :---: |</span><br><span class="line">| Computer | 1600 USD  | 5     |</span><br></pre></td></tr></table></figure><h4 id="12-代码块"><a href="#12-代码块" class="headerlink" title="12.代码块"></a>12.代码块</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">行间：`code`</span><br><span class="line">代码块：`*3 code `*3</span><br><span class="line">代码块(高亮)：`*3 python </span><br><span class="line">some python code</span><br><span class="line">`*3</span><br></pre></td></tr></table></figure><h4 id="13-LaTex公式"><a href="#13-LaTex公式" class="headerlink" title="13.LaTex公式"></a>13.LaTex公式</h4><p>数学公式的默认定界符是<code>$...$</code>和<code>\\(...\\)</code>（对于行内公式），以及<code>$$ ... $$</code>和<code>\\[...\\]</code>（对于块级公式）</p><script type="math/tex; mode=display">R_{m \times n}</script><p>参考<br><a href="https://hyxxsfwy.github.io/2016/01/15/Hexo-Markdown-%E7%AE%80%E6%98%8E%E8%AF%AD%E6%B3%95%E6%89%8B%E5%86%8C/#fn1" target="_blank" rel="noopener">[1]Hexo Markdown 简明语法手册 - Mobilicorpus</a><br><a href="http://itmyhome.com/markdown/article/syntax/blockquotes.html" target="_blank" rel="noopener">[2]Learning-Markdown (Markdown 入门参考) - LearnShare</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;总结下Hexo Markdown的语法，发现很多东西都只支持原生markdown。&lt;br&gt;
    
    </summary>
    
    
      <category term="Tutorial" scheme="https://jiaomawhu.github.io/tags/Tutorial/"/>
    
  </entry>
  
</feed>
